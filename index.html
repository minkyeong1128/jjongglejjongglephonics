<!doctypehtml>
   <html lang="ko">
    <meta charset="UTF-8">
    <meta content="width=device-width,initial-scale=1" name="viewport">
    <title>쫑글쫑글 파닉스</title>
    
    <!-- Firebase SDK -->
   <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
  // Android TTS Bridge 연결 및 Web Speech API 대체
  (function() {
      console.log('TTS Bridge 초기화 중...');

      const isAndroidTTSAvailable = () => {
          return typeof window.AndroidTTS !== 'undefined';
      };

      if (isAndroidTTSAvailable() || !('speechSynthesis' in window)) {
          console.log('Android TTS 또는 Web Speech API 미지원 - Bridge 모드 활성화');

          if (!window.SpeechSynthesisUtterance || isAndroidTTSAvailable()) {
              window.SpeechSynthesisUtterance = function(text) {
                  this.text = text || '';
                  this.lang = 'ko-KR';
                  this.rate = 1.0;
                  this.pitch = 1.0;
                  this.volume = 1.0;
                  this.onstart = null;
                  this.onend = null;
                  this.onerror = null;
              };
          }

          window.speechSynthesis = {
              speaking: false,
              pending: false,
              paused: false,

              speak: function(utterance) {
                  console.log('TTS Bridge speak():', utterance.text);

                  if (isAndroidTTSAvailable()) {
                      try {
                          this.speaking = true;

                          if (utterance.onstart) {
                              setTimeout(utterance.onstart, 50);
                          }

                          window.AndroidTTS.speak(
                              utterance.text,
                              utterance.rate || 1.0,
                              utterance.pitch || 1.0
                          );

                          setTimeout(() => {
                              this.speaking = false;
                              if (utterance.onend) {
                                  utterance.onend();
                              }
                          }, Math.max(utterance.text.length * 100, 500));

                      } catch (error) {
                          console.error('Android TTS Error:', error);
                          this.speaking = false;
                          if (utterance.onerror) {
                              utterance.onerror(error);
                          }
                      }
                  } else {
                      console.warn('TTS 사용 불가 - 음성 재생 불가');
                      if (utterance.onerror) {
                          utterance.onerror(new Error('TTS not available'));
                      }
                  }
              },

              cancel: function() {
                  console.log('TTS cancel()');
                  if (isAndroidTTSAvailable()) {
                      window.AndroidTTS.stop();
                  }
                  this.speaking = false;
                  this.pending = false;
              },

              pause: function() {
                  if (isAndroidTTSAvailable()) {
                      window.AndroidTTS.pause();
                  }
                  this.paused = true;
              },

              getVoices: function() {
                  return [{
                      name: 'Korean',
                      lang: 'ko-KR',
                      default: true
                  }];
              }
          };

          console.log('TTS Bridge 설정 완료');
      }

      window.addEventListener('DOMContentLoaded', function() {
          if (isAndroidTTSAvailable()) {
              console.log('Android TTS 사용 가능');

              setTimeout(() => {
                  if (window.AndroidTTS && window.AndroidTTS.isAvailable()) {
                      console.log('TTS 테스트 실행');
                      window.AndroidTTS.test();
                  }
              }, 1000);
          }
      });
  })();
</script>

    <style>
        *{margin:0;padding:0;box-sizing:border-box}body{font-family:Arial,sans-serif;background:#ffeb3b;min-height:100vh;display:flex;justify-content:center;align-items:center;padding:20px}.main-container{background:#fff;border-radius:25px;box-shadow:0 20px 40px rgba(0,0,0,.1);padding:40px;max-width:500px;width:100%;text-align:center;position:relative;overflow:hidden}.main-container::before{content:'';position:absolute;top:-50%;left:-50%;width:200%;height:200%;background:linear-gradient(45deg,transparent,rgba(255,255,255,.1),transparent);transform:rotate(45deg);animation:shine 3s infinite}@keyframes shine{0%{transform:translateX(-100%) translateY(-100%) rotate(45deg)}100%{transform:translateX(100%) translateY(100%) rotate(45deg)}}.character{font-size:80px;margin-top:15px;margin-bottom:10px;transform:translateY(20px)}.main-title{font-size:32px;font-weight:700;color:#4a5568;margin-bottom:15px;text-shadow:2px 2px 4px rgba(0,0,0,.1)}.main-subtitle{font-size:16px;color:#718096;margin-bottom:40px}.menu-buttons{display:flex;flex-direction:column;gap:20px;margin-bottom:30px}.menu-button{background:linear-gradient(135deg,#4facfe,#00f2fe);border:none;border-radius:20px;color:#fff;padding:20px 30px;font-size:18px;font-weight:700;cursor:pointer;transition:all .3s ease;box-shadow:0 8px 16px rgba(79,172,254,.3);position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.menu-button:hover{transform:translateY(-3px);box-shadow:0 12px 24px rgba(79,172,254,.4)}.menu-button.secondary{background:linear-gradient(135deg,#ff6b6b,#ff8e8e);box-shadow:0 8px 16px rgba(255,107,107,.3)}.menu-button.secondary:hover{box-shadow:0 12px 24px rgba(255,107,107,.4)}.menu-button.tertiary{background:linear-gradient(135deg,#28a745,#20c997);box-shadow:0 8px 16px rgba(40,167,69,.3)}.menu-button.tertiary:hover{box-shadow:0 12px 24px rgba(40,167,69,.4)}.back-button{position:absolute;top:20px;left:20px;background:#fff;border:none;border-radius:50%;width:30px;height:30px;color:#666;font-size:20px;cursor:pointer;transition:all .3s ease;box-shadow:0;-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.back-button:hover{transform:translateY(-2px);box-shadow:0 6px 12px rgba(253,203,110,.4)}.hidden{display:none!important}.title{font-size:28px;font-weight:700;color:#4a5568;margin-bottom:10px;text-shadow:2px 2px 4px rgba(0,0,0,.1)}.subtitle{font-size:16px;color:#718096;margin-bottom:30px}.voice-section{margin-bottom:30px}.mic-button{width:80px;height:80px;border-radius:50%;border:none;background:linear-gradient(135deg,#ff6b6b,#ff8e8e);color:#fff;font-size:30px;cursor:pointer;transition:all .3s ease;box-shadow:0 8px 16px rgba(255,107,107,.3);position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.mic-button:hover{transform:translateY(-2px);box-shadow:0 12px 24px rgba(255,107,107,.4)}.mic-button.recording{background:linear-gradient(135deg,#48bb78,#68d391);animation:pulse 1.5s infinite}@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.05)}100%{transform:scale(1)}}.voice-status{margin-top:15px;font-size:14px;color:#666;min-height:20px}.result-section{margin:30px 0}.original-text{background:#f8f9fa;padding:20px;border-radius:15px;margin-bottom:20px;font-size:18px;font-weight:700;color:#1565c0;min-height:60px;display:flex;align-items:center;justify-content:center}.phonics-container{background:#f8f9fa;padding:20px;border-radius:15px;margin-bottom:20px}.phonics-grid{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-bottom:20px}.syllable-group{display:flex;flex-direction:column;align-items:center;margin:10px;padding:10px;border-radius:15px;background:rgba(255,255,255,.5);border:2px dashed #ccc}.syllable-label{font-size:18px;font-weight:700;color:#333;margin-bottom:10px;padding:5px 10px;background:#fff;border-radius:10px;box-shadow:0 2px 4px rgba(0,0,0,.1)}.syllable-phonics{display:flex;gap:5px;flex-wrap:wrap;justify-content:center}.phonics-item{background:#fff;border-radius:12px;padding:15px;box-shadow:0 4px 8px rgba(0,0,0,.1);cursor:pointer;transition:all .3s ease;min-width:70px;position:relative;border:2px solid transparent;-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.phonics-item:hover{transform:translateY(-2px);box-shadow:0 6px 12px rgba(0,0,0,.15);background:#f8f9ff}.phonics-item.playing{background:linear-gradient(135deg,#fff59d,#ffeb3b);transform:scale(1.05)}.phonics-item.consonant{border-color:#ff6b6b;background:linear-gradient(135deg,#fff5f5,#fed7d7)}.phonics-item.vowel{border-color:#4299e1;background:linear-gradient(135deg,#f0f8ff,#bee3f8)}.phonics-item.final{border-color:#38a169;background:linear-gradient(135deg,#f0fff4,#c6f6d5)}.jamo{font-size:24px;font-weight:700;color:#2d3748;margin-bottom:8px;font-family:'Malgun Gothic',Arial,sans-serif}.pronunciation{font-size:14px;color:#4a5568;font-weight:500;margin-bottom:4px}.jamo-type{font-size:10px;color:#718096;font-style:italic;padding:2px 6px;border-radius:8px;display:inline-block}.jamo-type.consonant{background:#fed7d7;color:#c53030}.jamo-type.vowel{background:#bee3f8;color:#2b6cb0}.jamo-type.final{background:#c6f6d5;color:#276749}.controls{display:flex;justify-content:center;align-items:center;gap:15px;flex-wrap:wrap;margin-top:20px}.control-button{background:linear-gradient(135deg,#4facfe,#00f2fe);border:none;border-radius:50px;color:#fff;padding:12px 20px;font-size:14px;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 8px rgba(79,172,254,.3);-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.control-button:hover{transform:translateY(-2px);box-shadow:0 6px 12px rgba(79,172,254,.4)}.control-button:disabled{opacity:.6;cursor:not-allowed;transform:none}.speed-control{display:flex;align-items:center;gap:10px;background:#fff;padding:10px 15px;border-radius:25px;box-shadow:0 4px 8px rgba(0,0,0,.1)}.speed-slider{width:100px;height:6px;border-radius:3px;background:#ddd;outline:0;-webkit-appearance:none}.speed-slider::-webkit-slider-thumb{-webkit-appearance:none;width:20px;height:20px;border-radius:50%;background:#4facfe;cursor:pointer}.reset-button{background:linear-gradient(135deg,#28a745,#20c997);border:none;border-radius:15px;color:#fff;padding:12px 20px;font-size:14px;font-weight:700;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 8px rgba(253,203,110,.3);-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.reset-button:hover{transform:translateY(-2px);box-shadow:0 6px 12px rgba(253,203,110,.4)}.loading{display:none;margin:20px 0}.spinner{width:40px;height:40px;border:4px solid #f3f3f3;border-top:4px solid #4facfe;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.emoji{font-size:24px;margin:0 5px}.demo-section{margin-bottom:20px;padding:15px;background:#f8f9fa;border-radius:15px}.demo-button{background:#dee2e6;border:none;border-radius:25px;color:#666;padding:10px 16px;font-size:14px;cursor:pointer;margin:5px;transition:all .3s ease;-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.demo-button:hover{transform:translateY(-1px);box-shadow:0 4px 8px rgba(40,167,69,.3)}.legend{display:flex;justify-content:center;gap:15px;margin-bottom:15px;flex-wrap:wrap}.legend-item{display:flex;align-items:center;gap:5px;font-size:12px;color:#666}.legend-color{width:12px;height:12px;border-radius:3px}.legend-color.consonant{background:#fed7d7}.legend-color.vowel{background:#bee3f8}.legend-color.final{background:#c6f6d5}.mode-selection{margin-bottom:30px;display:flex;justify-content:center;gap:20px;flex-wrap:wrap}.mode-button{background:#fff;border:2px solid #ddd;border-radius:15px;padding:12px 20px;color:#666;font-size:14px;cursor:pointer;transition:all .3s ease;font-weight:700}.mode-button:hover{transform:translateY(-3px);box-shadow:0 8px 20px rgba(0,0,0,.3)}.mode-button.active{background:#fff9c4;border-color:#ffeb3b}.score-board{display:flex;justify-content:space-between;margin-bottom:20px;padding:15px;background:#fff;border-radius:15px;color:#000;font-weight:400}.question-area{margin-bottom:30px}.question-number{font-size:16px;color:#718096;margin-bottom:10px}.word-image{width:200px;height:200px;margin:20px auto;border-radius:15px;background:#fff;position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center}.word-image img{width:100%;height:100%;object-fit:cover;border-radius:12px}
.word-image .loading{font-size:2em;color:#5a67d8}
.word-image,.word-image *,.word-image div,.word-image span{text-decoration:none !important;text-decoration-line:none !important;text-decoration-color:transparent !important;text-decoration-style:none !important;text-decoration-thickness:0 !important;text-underline-offset:0 !important;text-decoration-skip:none !important;text-decoration-skip-ink:none !important;-webkit-text-decoration:none !important;-webkit-text-decoration-line:none !important;-webkit-text-decoration-color:transparent !important;-webkit-text-decoration-style:none !important;-webkit-text-underline-position:unset !important;-moz-text-decoration-line:none !important;-moz-text-decoration-color:transparent !important;-moz-text-decoration-style:none !important;background-image:none !important;border-bottom:none !important;border-top:none !important;box-shadow:none !important}
.audio-button{background:linear-gradient(135deg,#ff6b6b,#ff8e8e);border:none;border-radius:50%;width:80px;height:80px;color:#fff;font-size:2em;cursor:pointer;margin-bottom:30px;box-shadow:0 5px 15px rgba(255,107,107,.4);transition:all .3s ease}.audio-button:hover{transform:scale(1.1);box-shadow:0 8px 20px rgba(255,107,107,.6)}.choices{display:flex;justify-content:center;gap:20px;flex-wrap:wrap;margin-bottom:30px}.choice-button{background:#fff;border:2px solid #ddd;border-radius:15px;padding:10px 20px;font-size:1.3em;color:#666;cursor:pointer;transition:all .3s ease;min-width:80px;box-shadow:0 5px 15px rgba(0,0,0,.1);font-weight:700;margin:10px}.choice-button:hover{transform:translateY(-3px);box-shadow:0 8px 20px rgba(0,0,0,.3)}.choice-button.correct{background:linear-gradient(135deg,#28a745,#20c997);color:#fff}.choice-button.incorrect{background:linear-gradient(45deg,#ff416c,#ff4b2b);color:#fff}.feedback{margin-top:20px;padding:15px;border-radius:10px;font-size:1.1em;font-weight:700}.feedback.correct{background:linear-gradient(45deg,#d4edda,#c3e6cb);color:#155724;border:2px solid #c3e6cb}.feedback.incorrect{background:linear-gradient(45deg,#f8d7da,#f5c6cb);color:#721c24;border:2px solid #f5c6cb}.next-button{background:linear-gradient(135deg,#28a745,#20c997);border:none;border-radius:10px;padding:12px 20px;color:#fff;font-size:14px;cursor:pointer;margin-top:20px;transition:all .3s ease;font-weight:700}.result-screen{display:none;text-align:center}.final-score{font-size:1.2em;color:#000;margin-bottom:20px;text-shadow:2px 2px 4px rgba(0,0,0,.1);line-height:1.5}.retry-button{background:linear-gradient(135deg,#28a745,#20c997);border:none;border-radius:15px;padding:12px 20px;color:#fff;font-size:14px;cursor:pointer;margin-top:20px;transition:all .3s ease;font-weight:700}.wrong-answers{text-align:left;margin-top:20px;padding:20px;background:#f8f9fa;border-radius:10px;border-left:5px solid #dc3545}.wrong-answer-item{margin-bottom:15px;padding:10px;background:#fff;border-radius:5px;border:1px solid #dee2e6}.jamo-tabs{display:flex;justify-content:center;gap:10px;margin-bottom:30px;flex-wrap:wrap}.jamo-tab-button{background:#fff;border:2px solid #ddd;border-radius:15px;padding:12px 20px;color:#666;font-size:14px;cursor:pointer;transition:all .3s ease;font-weight:700}.jamo-tab-button:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,.2)}.jamo-tab-button.active{background:#fff9c4;border-color:#ffeb3b}.jamo-tab-content{margin-bottom:20px}.jamo-section-title{text-align:center;color:#4a5568;margin-bottom:20px;font-size:20px}.jamo-cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:15px;padding:20px;max-width:600px;margin:0 auto}.jamo-card{background:#fff;border:3px solid transparent;border-radius:15px;padding:20px;text-align:center;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 8px rgba(0,0,0,.1);position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none}.jamo-card:hover{transform:translateY(-3px);box-shadow:0 6px 12px rgba(0,0,0,.15)}.jamo-card.playing{transform:scale(1.05);border-color:#ffeb3b;background:linear-gradient(135deg,#fff59d,#ffeb3b)}.jamo-card.consonant-card{border-color:#ff6b6b;background:linear-gradient(135deg,#fff5f5,#fed7d7)}.jamo-card.vowel-card{border-color:#4299e1;background:linear-gradient(135deg,#f0f8ff,#bee3f8)}.jamo-card.final-card{border-color:#38a169;background:linear-gradient(135deg,#f0fff4,#c6f6d5)}.jamo-card-jamo{font-size:32px;font-weight:700;color:#2d3748;margin-bottom:10px;font-family:'Malgun Gothic',Arial,sans-serif}.jamo-card-sound{font-size:16px;color:#4a5568;font-weight:500;margin-bottom:5px}.jamo-card-type{font-size:12px;color:#718096;padding:3px 8px;border-radius:10px;display:inline-block;font-weight:700}.jamo-card-type.consonant-type{background:#fed7d7;color:#c53030}.jamo-card-type.vowel-type{background:#bee3f8;color:#2b6cb0}.jamo-card-type.final-type{background:#c6f6d5;color:#276749}.modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);display:flex;justify-content:center;align-items:center;z-index:1000}.modal-content{background:#fff;border-radius:20px;padding:30px;max-width:450px;width:90%;max-height:90%;overflow-y:auto;position:relative;box-shadow:0 20px 40px rgba(0,0,0,.3)}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;border-bottom:2px solid #f0f0f0;padding-bottom:15px}.modal-title{font-size:20px;font-weight:700;color:#2d3748;margin:0;font-family:'Malgun Gothic',Arial,sans-serif}.modal-close{background:0 0;border:none;font-size:30px;color:#999;cursor:pointer;padding:5px 10px;border-radius:50%;transition:all .3s ease}.modal-close:hover{background:#f0f0f0;color:#666}.stroke-info{display:flex;align-items:center;justify-content:center;margin-bottom:20px;padding:15px;background:linear-gradient(135deg,#f8f9fa,#e9ecef);border-radius:15px}.sound-replay-btn{background:linear-gradient(135deg,#ff6b6b,#ff8e8e);border:none;border-radius:25px;padding:12px 20px;color:#fff;font-size:14px;font-weight:700;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 8px rgba(255,107,107,.3)}.sound-replay-btn:hover{transform:translateY(-2px);box-shadow:0 6px 12px rgba(255,107,107,.4)}.sound-replay-btn:hover{transform:scale(1.1)}.stroke-canvas-container{text-align:center;margin-bottom:20px}#strokeCanvas{border:3px solid #ddd;border-radius:15px;background:#fafafa;cursor:crosshair;touch-action:none}.stroke-controls{display:flex;justify-content:center;gap:10px;margin-top:15px;flex-wrap:wrap}.stroke-btn{background:linear-gradient(135deg,#4facfe,#00f2fe);border:none;border-radius:25px;color:#fff;padding:10px 15px;font-size:14px;cursor:pointer;transition:all .3s ease;font-weight:700}.stroke-btn:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(79,172,254,.3)}@media (max-width:480px){.main-container{padding:20px;margin:10px}.main-title{font-size:24px}.menu-button{padding:15px 20px;font-size:16px}.mic-button{width:70px;height:70px;font-size:25px}.phonics-grid{gap:8px}.phonics-item{min-width:60px;padding:12px}.controls{gap:10px}.speed-control{padding:8px 12px}.legend{gap:10px}.syllable-group{margin:5px;padding:8px}.mode-selection{gap:10px}.mode-button{padding:12px 18px;font-size:14px}.jamo-tabs{gap:5px}.jamo-tab-button{padding:10px 15px;font-size:12px}.jamo-cards-grid{grid-template-columns:repeat(auto-fit,minmax(80px,1fr));gap:10px;padding:15px}.jamo-card{padding:15px}.jamo-card-jamo{font-size:24px;margin-bottom:8px}.jamo-card-sound{font-size:14px;margin-bottom:4px}.jamo-card-type{font-size:10px;padding:2px 6px}.modal-content{padding:20px;max-width:95%}.modal-title{font-size:36px}.modal-close{font-size:24px}#strokeCanvas{width:100%;max-width:280px;height:280px}.stroke-controls{gap:8px}.stroke-btn{padding:8px 12px;font-size:12px}}
  
/* 메인 컨테이너 수정 */
        .main-container {
            position: relative;
            overflow: hidden;
        }
/* 로그인 버튼 스타일 */
        .login-area {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 100;
        }

    .login-btn {
            background: none;
            color: #333;
            border: none;
            padding: 8px 16px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .login-btn:hover {
            opacity: 0.7;
        }

        .logout-btn {
            background: none;
            color: #ff6b6b;
            border: none;
            padding: 8px 16px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .logout-btn:hover {
            opacity: 0.7;
        }

   .stats-btn {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            font-size: 20px;
            padding: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
            color: inherit;
        }

        .stats-btn:hover {
            background: none !important;
            transform: scale(1.1);
        }

      .user-info {
            display: none;
            align-items: center;
            gap: 8px;
            font-size: 15px;
        }

        .user-nickname {
            font-weight: bold;
            color: #333;
        }

        /* 로그인/회원가입 모달 스타일 */
        .auth-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .auth-modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .auth-modal h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .auth-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 14px;
            color: #666;
            border-bottom: 2px solid transparent;
        }

        .auth-tab.active {
            color: #4CAF50;
            border-bottom-color: #4CAF50;
        }

       .auth-form, #findForm {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 100%;
}

.auth-form input, .auth-form select, #findForm input {
    width: 100%;
    box-sizing: border-box;
}

    .auth-form input, .auth-form select, #findForm input, #findForm button {
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: 14px;
}

        .auth-form input:focus {
            outline: none;
            border-color: #4CAF50;
        }

    .auth-form button, #findForm button {
   width: 100%;
    box-sizing: border-box;
    background: #4CAF50;
    color: white;
    border: none;
    padding: 12px;
    border-radius: 8px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.3s;
}

.auth-form button:hover, #findForm button:hover {
    background: #45a049;
}

.auth-links {
    display: flex;
    justify-content: flex-end;
    margin-top: 10px;
}

.link-btn {
    background: transparent !important;
    border: none !important;
    color: #ff6b6b !important;
    font-size: 12px;
    cursor: pointer;
    text-decoration: underline;
    box-shadow: none !important;
    outline: none !important;
}

.birthdate-container {
    display: flex;
    gap: 4px;
    width: 100% !important;
    max-width: 350px !important; /* 강제로 너비 제한 */
    box-sizing: border-box !important;
  margin-top: 15px; /* 이름 입력창과의 간격 추가 */
 margin-bottom: 15px; /* 찾기 버튼과의 간격 추가 */
}

.birthdate-container select {
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: 14px;
    flex: 1;
    min-width: 0;
    box-sizing: border-box;
}

.birthdate-container select:first-child {
    flex: 1.3;
}

.birthdate-container select:focus {
    outline: none;
    border-color: #4CAF50;
}

.signup-birthdate-container {
    display: flex;
    gap: 4px;
    width: 100% !important;
    max-width: 350px !important;
    box-sizing: border-box !important;
    /* margin 제거 - .auth-form의 gap으로 간격 통일 */
}

.signup-birthdate-container select {
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: 14px;
    flex: 1;
    min-width: 0;
    box-sizing: border-box;
}

.signup-birthdate-container select:first-child {
    flex: 1.3;
}

.signup-birthdate-container select:focus {
    outline: none;
    border-color: #4CAF50;
}

.link-btn:hover {
    color: #ff8e8e !important;
    background: transparent !important;
    box-shadow: none !important;
}

.link-btn:focus {
    color: #ff6b6b !important;
    background: transparent !important;
    box-shadow: none !important;
    outline: none !important;
}

.link-btn:active {
    color: #ff6b6b !important;
    background: transparent !important;
    box-shadow: none !important;
}

        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }
/* 통계 모달 스타일 추가 */
.stats-tabs {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 2px solid #e0e0e0;
    gap: 5px;
}

.stats-tab {
    flex: 1;
    padding: 12px 8px;
    background: none;
    border: none;
    color: #666;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: all 0.3s ease;
}

.stats-tab.active {
    color: #4facfe;
    border-bottom-color: #4facfe;
    background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.05));
}

.stats-tab:hover:not(.active) {
    color: #333;
    background: rgba(0, 0, 0, 0.05);
}

.stats-tab-content {
    display: none;
    animation: fadeIn 0.3s ease-in-out;
}

.stats-tab-content.active {
    display: block;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.stats-section-title {
    text-align: center;
    color: #4a5568;
    margin-bottom: 20px;
    font-size: 18px;
    font-weight: 700;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
    margin-bottom: 30px;
}

.stat-item {
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    padding: 15px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

.stat-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}

.stat-item.excellent {
    border-color: #38a169;
    background: linear-gradient(135deg, #f0fff4, #c6f6d5);
}

.stat-item.excellent::before {
    content: '🌟';
    position: absolute;
    top: 5px;
    right: 8px;
    font-size: 14px;
}

.stat-item.good {
    border-color: #4299e1;
    background: linear-gradient(135deg, #f0f8ff, #bee3f8);
}

.stat-item.good::before {
    content: '👍';
    position: absolute;
    top: 5px;
    right: 8px;
    font-size: 14px;
}

.stat-item.average {
    border-color: #ed8936;
    background: linear-gradient(135deg, #fffaf0, #fbd38d);
}

.stat-item.average::before {
    content: '⚡';
    position: absolute;
    top: 5px;
    right: 8px;
    font-size: 14px;
}

.stat-item.needs-practice {
    border-color: #e53e3e;
    background: linear-gradient(135deg, #fff5f5, #fed7d7);
}

.stat-item.needs-practice::before {
    content: '🎯';
    position: absolute;
    top: 5px;
    right: 8px;
    font-size: 14px;
}

.stat-item.no-data {
    border-color: #a0aec0;
    background: linear-gradient(135deg, #f7fafc, #edf2f7);
    opacity: 0.7;
}

.stat-item.no-data::before {
    content: '❓';
    position: absolute;
    top: 5px;
    right: 8px;
    font-size: 14px;
}

.stat-jamo {
    font-size: 32px;
    font-weight: 700;
    color: #2d3748;
    margin-bottom: 10px;
    font-family: 'Malgun Gothic', Arial, sans-serif;
}

.stat-bar {
    width: 100%;
    height: 8px;
    background: #e2e8f0;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 8px;
}

.stat-fill {
    height: 100%;
    background: linear-gradient(90deg, #4facfe, #00f2fe);
    border-radius: 4px;
    transition: width 1s ease-out;
}

.stat-percentage {
    font-size: 14px;
    font-weight: 600;
    color: #4a5568;
}

.practice-section {
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    padding: 20px;
    border-radius: 15px;
    margin-top: 20px;
}

.practice-title {
    font-size: 16px;
    font-weight: 700;
    color: #4a5568;
    margin-bottom: 15px;
    text-align: center;
}

.practice-items {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
}

.practice-item {
    background: white;
    border: 2px solid #e53e3e;
    border-radius: 10px;
    padding: 8px 16px;
    font-size: 18px;
    font-weight: 700;
    color: #e53e3e;
    cursor: pointer;
    transition: all 0.3s ease;
    animation: pulse 2s infinite;
}

.practice-item:hover {
    background: #e53e3e;
    color: white;
    transform: scale(1.05);
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
}

/* 반응형 디자인 */
@media (max-width: 480px) {
    .stats-tabs {
        flex-wrap: wrap;
        gap: 2px;
    }
    
    .stats-tab {
        font-size: 12px;
        padding: 8px 4px;
    }
    
    .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
        gap: 10px;
    }
    
    .stat-item {
        padding: 10px;
    }
    
    .stat-jamo {
        font-size: 24px;
        margin-bottom: 8px;
    }
    
    .practice-items {
        gap: 8px;
    }
    
    .practice-item {
        padding: 6px 12px;
        font-size: 16px;
    }
}

/* 통계 데이터 로딩 애니메이션 */
.loading-stats {
    text-align: center;
    padding: 40px;
    color: #666;
}

.loading-stats::before {
    content: '📊';
    display: block;
    font-size: 48px;
    margin-bottom: 15px;
    animation: bounce 1s infinite;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

#findForm .back-button {
    position: absolute;
    top: 15px;
    left: 15px;
    background: transparent !important;
    border: none !important;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    color: #666;
    font-size: 20px;
    cursor: pointer;
    transition: all .3s ease;
    box-shadow: none !important;
}

#findForm .back-button:hover {
    transform: translateY(-2px);
    background: transparent !important;
    box-shadow: none !important;
}

/* 탈퇴 버튼 스타일 */
.withdraw-btn {
    background: none;
    color: #e74c3c;
    border: none;
    padding: 8px 16px;
    font-size: 15px;
    font-weight: bold;
    cursor: pointer;
    transition: opacity 0.3s ease;
}

.withdraw-btn:hover {
    opacity: 0.7;
}

/* 탈퇴 확인 모달 스타일 */
.withdraw-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    z-index: 1001;
    justify-content: center;
    align-items: center;
}

.withdraw-modal-content {
    background: white;
    padding: 30px;
    border-radius: 15px;
    width: 90%;
    max-width: 400px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    text-align: center;
    position: relative;
}

.withdraw-modal h3 {
    color: #e74c3c;
    margin-bottom: 20px;
    font-size: 18px;
}

.withdraw-modal p {
    color: #666;
    line-height: 1.5;
    margin-bottom: 30px;
}

.withdraw-modal-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.withdraw-confirm-btn, .withdraw-cancel-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
}

.withdraw-confirm-btn {
    background: #e74c3c;
    color: white;
}

.withdraw-confirm-btn:hover {
    background: #c0392b;
}

.withdraw-cancel-btn {
    background: #95a5a6;
    color: white;
}

.withdraw-cancel-btn:hover {
    background: #7f8c8d;
}
</style>
    <div class="main-container">
  <!-- 로그인 영역 -->
        <div class="login-area">
            <div class="user-info" id="userInfo">
                <span class="user-nickname" id="userNickname"></span>
            </div>
            <button class="login-btn" id="loginBtn" onclick="showAuthModal()">로그인(회원가입)</button>
            <button class="stats-btn" id="statsBtn" onclick="showStatsModal()" style="display: none;">📊</button>
            <button class="logout-btn" id="logoutBtn" onclick="logout()" style="display: none;">로그아웃</button>
<button class="withdraw-btn" id="withdrawBtn" onclick="showWithdrawModal()" style="display: none;">탈퇴</button>
        </div>

        <!-- 로그인/회원가입 모달 -->
        <div class="auth-modal" id="authModal">
            <div class="auth-modal-content">
                <button class="close-modal" onclick="closeAuthModal()">×</button>
                <h2>쫑글쫑글 파닉스</h2>
                
                <div class="auth-tabs">
                    <button class="auth-tab active" onclick="switchAuthTab('login')">로그인</button>
                    <button class="auth-tab" onclick="switchAuthTab('signup')">회원가입</button>
                </div>

                <form class="auth-form" id="authForm">
    <input type="text" id="username" placeholder="아이디" required>
    <input type="password" id="password" placeholder="비밀번호" required>
    <input type="text" id="nickname" placeholder="이름" style="display: none;">
    <div class="signup-birthdate-container" style="display: none;">
    <select id="signupYear">
        <option value="">연도</option>
    </select>
    <select id="signupMonth">
        <option value="">월</option>
    </select>
    <select id="signupDay">
        <option value="">일</option>
    </select>
</div>
    <button type="submit" id="authSubmitBtn">로그인</button>
   <div class="auth-links" id="authLinks">
    <button type="button" class="link-btn" onclick="showFindForm()">아이디/비밀번호 찾기</button>
</div>
</form>

<!-- 아이디/비밀번호 찾기 폼 -->
<div class="auth-form hidden" id="findForm">
    <button class="back-button" onclick="hideFindForm()">🔙</button>
    
      
    <form id="findFormContent">
        <input type="text" id="findName" placeholder="이름" required>
    <div class="birthdate-container">
    <select id="findYear" required>
        <option value="">연도</option>
    </select>
    <select id="findMonth" required>
        <option value="">월</option>
    </select>
    <select id="findDay" required>
        <option value="">일</option>
    </select>
</div>
        <button type="submit" id="findSubmitBtn">찾기</button>
    </form>
</div>
            </div>
        </div>
        <div id="mainMenu">
        <div class="character">
    <img alt="쫑글이" 
         src="https://raw.githubusercontent.com/minkyeong1128/main-image/main/images/rabbit.png" 
         style="width:150px;height:150px;object-fit:contain"
         loading="eager">
</div>
            <h1 class="main-title">쫑글쫑글 파닉스</h1>
            <p class="main-subtitle">한글 소리 놀이를 시작해보세요!
            <div class="menu-buttons"><button class="menu-button tertiary" onclick="showJamoLearning()">📝 자음·모음 배우기<br><small>자음, 모음, 받침을 하나씩 배워보세요</small></button> <button class="menu-button" onclick="showSoundAnalysis()">🎤 소리 놀이<br><small>단어를 말하면 자음·모음·받침으로 나누어 들려줘요</small></button> <button class="menu-button secondary" onclick="showSoundGame()">🎮 소리 맞추기 게임<br><small>소리를 듣고 맞는 단어를 찾아보세요</small></button></div>
        </div>
        <div class="hidden" id="soundAnalysisScreen"><button class="back-button" onclick="showMainMenu()">🔙</button>
            <h1 class="title">🎤 소리 놀이</h1>
            <p class="subtitle">단어를 말하면 자음과 모음, 받침으로 나누어 들려줄게요!
            <div class="demo-section">
                <p style="margin-bottom:10px;font-size:14px;color:#666">예시 단어로 테스트해보세요:</p><button class="demo-button" onclick='testWord("사과")'>사과</button> <button class="demo-button" onclick='testWord("딸기")'>딸기</button> <button class="demo-button" onclick='testWord("쭈꾸미")'>쭈꾸미</button> <button class="demo-button" onclick='testWord("뽀뽀")'>뽀뽀</button> <button class="demo-button" onclick='testWord("학교")'>학교</button> <button class="demo-button" onclick='testWord("안녕")'>안녕</button>
            </div>
            <div class="voice-section"><button class="mic-button" id="micButton">🎤</button>
                <div class="voice-status" id="voiceStatus">마이크 버튼을 눌러 단어를 말해보세요</div>
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>분석중이에요... 잠시만 기다려주세요!
            </div>
            <div class="hidden result-section" id="resultSection">
                <div class="original-text" id="originalText"><span class="emoji">💬</span> 여기에 인식된 단어가 나타나요 <span class="emoji">💬</span></div>
                <div class="phonics-container">
                    <h3 style="margin-bottom:15px;color:#f57c00">자음과 모음, 받침으로 나누어보기</h3>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color consonant"></div><span>자음</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color vowel"></div><span>모음</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color final"></div><span>받침</span>
                        </div>
                    </div>
                    <div class="phonics-grid" id="phonicsGrid"></div>
                    <div class="controls"><button class="control-button" id="playAllButton">▶️ 전체 재생</button>
                            <div class="speed-control"><span>🐌</span> <input class="speed-slider" id="speedSlider" max="2.0" min="0.5" step="0.1" type="range" value="0.6"> <span>🐰</span> <span id="speedDisplay">0.6x</span></div>
                    </div>
                </div><button class="reset-button" id="resetButton">다시 시작</button>
            </div>
        </div>
        <div class="hidden" id="gameScreen"><button class="back-button" onclick="showMainMenu()">🔙</button>
            <h1 class="title">🎮 소리 맞추기 게임</h1>
            <div class="question-area">
                <div class="question-number">단어의 자음·모음·받침 소리를 듣고 맞는 단어를 선택하세요!</div><br><br>
                <div class="mode-selection"><button class="active mode-button" onclick='setMode("noBatchim")' id="noBatchimMode">받침 없는 단어</button> <button class="mode-button" onclick='setMode("batchim")' id="batchimMode">받침 있는 단어</button></div>
                <div id="gameArea">
                    <div class="score-board">
                        <div>문제: <span id="currentQuestion">1</span> / 10</div>
                        <div>점수: <span id="score">0</span>점</div>
                    </div>
                    <div class="word-image" id="wordImage">
                        <div class="icon icon-apple"></div>
                    </div><button class="audio-button" onclick="playAudio()" id="audioButton">🔊</button>
                    <div class="choices" id="choices"></div>
                    <div class="hidden feedback" id="feedback"></div><button class="hidden next-button" onclick="nextQuestion()" id="nextButton">다음 문제</button>
                </div>
            </div>
            <div class="result-screen" id="resultScreen">
                <div class="final-score" id="finalScore"></div>
                <div class="wrong-answers" id="wrongAnswers"></div><button class="retry-button" onclick="restartGame()">다시 시작</button>
            </div>
        </div>
        <div class="hidden" id="jamoLearningScreen"><button class="back-button" onclick="showMainMenu()">🔙</button>
            <h1 class="title">📝 자음·모음 배우기</h1>
            <p class="subtitle">각 글자를 클릭하면 소리를 들을 수 있어요!
            <div class="jamo-tabs"><button class="jamo-tab-button active" onclick='showJamoTab("consonants")'>자음 (ㄱㄴㄷ...)</button> <button class="jamo-tab-button" onclick='showJamoTab("vowels")'>모음 (ㅏㅓㅗ...)</button> <button class="jamo-tab-button" onclick='showJamoTab("finals")'>받침 (ㄱㄴㄷ...)</button></div>
            <div class="jamo-tab-content" id="consonantsTab">
                <h3 class="jamo-section-title">자음 (초성)</h3>
                <div class="jamo-cards-grid" id="consonantsGrid"></div>
            </div>
            <div class="hidden jamo-tab-content" id="vowelsTab">
                <h3 class="jamo-section-title">모음 (중성)</h3>
                <div class="jamo-cards-grid" id="vowelsGrid"></div>
            </div>
            <div class="hidden jamo-tab-content" id="finalsTab">
                <h3 class="jamo-section-title">받침 (종성)</h3>
                <div class="jamo-cards-grid" id="finalsGrid"></div>
            </div>
        </div>
        <div class="hidden modal" id="strokeOrderModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title" id="modalJamoTitle">ㄱ</h3><button class="modal-close" onclick="closeStrokeModal()">×</button>
                </div>
                <div class="modal-body">
                    <div class="stroke-info"><button class="sound-replay-btn" id="soundReplayBtn">🔊</button></div>
                    <div class="stroke-canvas-container"><canvas height="300" id="strokeCanvas" width="300"></canvas>
                        <div class="stroke-controls"><button class="stroke-btn" onclick="clearCanvas()">🧹 지우기</button></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- 통계 모달 HTML (기존 strokeOrderModal 다음에 추가) -->
<div class="hidden modal" id="statsModal">
    <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
        <div class="modal-header">
            <h3 class="modal-title">📊 학습 통계</h3>
            <button class="modal-close" onclick="closeStatsModal()">×</button>
        </div>
        <div class="modal-body">
            <!-- 탭 버튼들 -->
            <div class="stats-tabs">
                <button class="stats-tab active" onclick="switchStatsTab('consonants')">자음</button>
                <button class="stats-tab" onclick="switchStatsTab('doubleConsonants')">쌍자음</button>
                <button class="stats-tab" onclick="switchStatsTab('vowels')">모음</button>
                <button class="stats-tab" onclick="switchStatsTab('doubleVowels')">이중모음</button>
                <button class="stats-tab" onclick="switchStatsTab('finals')">받침</button>
            </div>
            
            <!-- 탭 내용들 -->
            <div class="stats-tab-content active" id="consonantsStats">
                <h4 class="stats-section-title">자음 학습 현황</h4>
                <div class="stats-grid" id="statsConsonantsGrid"></div>
              <div class="practice-section" id="statsConsonantsPractice"></div>
            </div>
            
            <div class="stats-tab-content" id="doubleConsonantsStats">
                <h4 class="stats-section-title">쌍자음 학습 현황</h4>
              <div class="stats-grid" id="statsDoubleConsonantsGrid"></div>
                <div class="practice-section" id="statsDoubleConsonantsPractice"></div>
            </div>
            
            <div class="stats-tab-content" id="vowelsStats">
                <h4 class="stats-section-title">모음 학습 현황</h4>
               <div class="stats-grid" id="statsVowelsGrid"></div>
               <div class="practice-section" id="statsVowelsPractice"></div>
            </div>
            
            <div class="stats-tab-content" id="doubleVowelsStats">
                <h4 class="stats-section-title">이중모음 학습 현황</h4>
               <div class="stats-grid" id="statsDoubleVowelsGrid"></div>
               <div class="practice-section" id="statsDoubleVowelsPractice"></div>
            </div>
            
            <div class="stats-tab-content" id="finalsStats">
                <h4 class="stats-section-title">받침 학습 현황</h4>
               <div class="stats-grid" id="statsFinalsGrid"></div>
               <div class="practice-section" id="statsFinalsPractice"></div>
            </div>
        </div>
    </div>
</div>
<!-- 탈퇴 확인 모달 (여기에 추가) -->
<div class="withdraw-modal" id="withdrawModal">
    <div class="withdraw-modal-content">
        <h3>⚠️ 회원 탈퇴</h3>
        <p>
            정말로 탈퇴하시겠습니까?<br>
            탈퇴 시 모든 학습 기록과 통계가<br>
            영구적으로 삭제되며 복구할 수 없습니다.
        </p>
        <div class="withdraw-modal-buttons">
            <button class="withdraw-cancel-btn" onclick="closeWithdrawModal()">취소</button>
            <button class="withdraw-confirm-btn" onclick="confirmWithdraw()">탈퇴하기</button>
        </div>
    </div>
</div>
    <script>
// Firebase 설정
const firebaseConfig = {
  apiKey: "AIzaSyBCdB4toFgq2zzSD_Z7UaoSrVCtq8UqdBs",
  authDomain: "hangul-phonics.firebaseapp.com",
  projectId: "hangul-phonics",
  storageBucket: "hangul-phonics.firebasestorage.app",
  messagingSenderId: "608578910312",
  appId: "1:608578910312:web:0a7041bc78931e2f5023dd"
};

// Firebase 초기화 (개선된 버전)
let db = null;

try {
    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
        console.log('Firebase 앱 초기화 완료');
    } else {
        console.log('Firebase 앱 이미 초기화됨');
    }
    
    db = firebase.firestore();
    console.log('Firestore 초기화 완료');
    
} catch (error) {
    console.error('Firebase 초기화 실패:', error);
    alert('서비스 초기화에 실패했습니다. 페이지를 새로고침해주세요.');
}

// 사용자 데이터 관리
let currentUser = null;
let currentAuthMode = 'login';

// Firestore에서 사용자 데이터 읽기
async function getUserData(username) {
    try {
        if (!db) {
            console.error('Firebase가 초기화되지 않았습니다.');
            return null;
        }
        
        const doc = await db.collection('users').doc(username).get();
        
        if (doc.exists) {  // exists() 대신 exists 사용
            const data = doc.data();
            console.log('데이터 로드 성공:', username);
            return data;
        } else {
            console.log('사용자를 찾을 수 없음:', username);
            return null;
        }
    } catch (error) {
        console.error('데이터 읽기 오류:', error);
        
        if (error.code === 'unavailable') {
            alert('네트워크 연결을 확인해주세요.');
        }
        
        return null;
    }
}

// Firestore에 사용자 데이터 저장
async function saveUserData(username, userData) {
    try {
        if (!db) {
            console.error('Firebase가 초기화되지 않았습니다.');
            return false;
        }
        
        await db.collection('users').doc(username).set(userData);
        console.log('사용자 데이터 저장 성공:', username);
        return true;
    } catch (error) {
        console.error('데이터 저장 오류:', error);
        
        if (error.code === 'permission-denied') {
            alert('데이터 저장 권한이 없습니다.');
        } else if (error.code === 'unavailable') {
            alert('네트워크 연결을 확인해주세요.');
        }
        
        return false;
    }
}

// Firestore에서 사용자 통계 업데이트
async function updateUserStats(username, stats) {
    try {
        await db.collection('users').doc(username).update({ stats: stats });
        return true;
    } catch (error) {
        console.error('통계 업데이트 오류:', error);
        return false;
    }
}
        // 로그인/회원가입 관련 함수들
      function showAuthModal() {
    console.log('모달 열기 시작'); // 디버깅용
    
    document.getElementById('authModal').style.display = 'flex';
    
    // 로그인/회원가입 탭 다시 보이기 (혹시 숨겨졌을 경우 대비)
    const authTabs = document.querySelector('.auth-tabs');
    if (authTabs) {
        authTabs.style.display = 'flex';
    }
    
    // 기본값으로 로그인 탭 설정 (더 안전하게)
    if (!currentAuthMode) {
        currentAuthMode = 'login';
    }
    switchAuthTab(currentAuthMode);
    
    // 폼 내용도 초기화
    document.getElementById('authForm').reset();
    
    // 찾기 폼이 열려있다면 숨기기
    document.getElementById('authForm').classList.remove('hidden');
    document.getElementById('findForm').classList.add('hidden');
    
    // 드롭다운 초기화 (모달이 완전히 렌더링된 후)
    setTimeout(() => {
        console.log('모달 렌더링 후 드롭다운 초기화 시작'); // 디버깅용
        initializeBirthdateDropdowns();
    }, 200); // 200ms 대기 후 초기화
    
    console.log('모달 열기 완료'); // 디버깅용
}


        function closeAuthModal() {
            document.getElementById('authModal').style.display = 'none';
            document.getElementById('authForm').reset();
        }

  function switchAuthTab(mode) {
    console.log(`탭 전환: ${mode}`); // 디버깅용
    
    currentAuthMode = mode;
    
    // 더 안전한 요소 선택 방법
    const authTabs = document.querySelectorAll('.auth-tab');
    if (authTabs.length < 2) {
        console.error('auth-tab 요소를 찾을 수 없습니다.');
        return;
    }
    
    const loginTab = authTabs[0];
    const signupTab = authTabs[1];
    const nicknameField = document.getElementById('nickname');
    const authLinks = document.getElementById('authLinks');
    const submitBtn = document.getElementById('authSubmitBtn');
    const birthdateContainer = document.querySelector('.signup-birthdate-container');
    
    // 필수 요소들이 모두 존재하는지 확인
    if (!loginTab || !signupTab || !nicknameField || !authLinks || !submitBtn || !birthdateContainer) {
        console.error('필요한 DOM 요소를 찾을 수 없습니다.');
        return;
    }
    
    if (mode === 'login') {
        loginTab.classList.add('active');
        signupTab.classList.remove('active');
        birthdateContainer.style.display = 'none';
        nicknameField.style.display = 'none';
        nicknameField.required = false;
        authLinks.style.display = 'flex';
        submitBtn.textContent = '로그인';
    } else {
        loginTab.classList.remove('active');
        signupTab.classList.add('active');
        birthdateContainer.style.display = 'flex';
        nicknameField.style.display = 'block';
        nicknameField.required = true;
        authLinks.style.display = 'none';
        submitBtn.textContent = '회원가입';
        
        // 회원가입 탭으로 전환될 때 드롭다운 다시 초기화
        setTimeout(() => {
            console.log('회원가입 탭 전환 후 드롭다운 초기화'); // 디버깅용
            initializeBirthdateDropdowns();
        }, 100);
    }
}

async function login(username, password) {
    try {
        const userData = await getUserData(username);
        
        // 사용자가 존재하지 않는 경우
        if (!userData) {
            return { success: false, message: '가입되지 않은 아이디입니다.' };
        }
        
        // 비밀번호가 틀린 경우
        if (userData.password !== password) {
            return { success: false, message: '비밀번호가 올바르지 않습니다.' };
        }
        
        // 로그인 성공
        currentUser = {
            username: username,
            nickname: userData.nickname,
            stats: userData.stats || {
                consonantErrors: {},
                vowelErrors: {},
                finalErrors: {},
                totalAttempts: 0,
                correctAttempts: 0
            }
        };
        updateLoginUI();
        closeAuthModal();
        // 로컬에 현재 사용자 정보 저장 (로그아웃할 때까지 유지)
        localStorage.setItem('currentUser', JSON.stringify({
            username: currentUser.username
        }));
        return { success: true };
    } catch (error) {
        console.error('로그인 오류:', error);
        return { success: false, message: '로그인 중 오류가 발생했습니다.' };
    }
}
    async function signup(username, password, nickname, birthdate) {
    try {
        // 이미 존재하는 사용자인지 확인
        const existingUser = await getUserData(username);
        if (existingUser) {
            return false;
        }
        
        const newUserData = {
            password: password,
            nickname: nickname,
            birthdate: birthdate, // birthdate 추가
            stats: {
                consonantErrors: {},
                vowelErrors: {},
                finalErrors: {},
                totalAttempts: 0,
                correctAttempts: 0
            },
            createdAt: new Date()
        };
        
        const success = await saveUserData(username, newUserData);
        if (success) {
            currentUser = {
                username: username,
                nickname: nickname,
                stats: newUserData.stats
            };
            
            updateLoginUI();
            closeAuthModal();
       // 로컬에 현재 사용자 정보 저장 (로그아웃할 때까지 유지)
localStorage.setItem('currentUser', JSON.stringify({
    username: currentUser.username
}));
            return true;
        }
        return false;
    } catch (error) {
        console.error('회원가입 오류:', error);
        return false;
    }
}

 function logout() {
    currentUser = null;
    localStorage.removeItem('currentUser');
    updateLoginUI();
}

        function updateLoginUI() {
            const loginBtn = document.getElementById('loginBtn');
            const logoutBtn = document.getElementById('logoutBtn');
 const withdrawBtn = document.getElementById('withdrawBtn');
            const statsBtn = document.getElementById('statsBtn');
            const userInfo = document.getElementById('userInfo');
            const userNickname = document.getElementById('userNickname');

            if (currentUser) {
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
withdrawBtn.style.display = 'inline-block';
                statsBtn.style.display = 'inline-block';
                userInfo.style.display = 'flex';
               userNickname.textContent = currentUser.nickname;
            } else {
                loginBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
withdrawBtn.style.display = 'none';
                statsBtn.style.display = 'none';
                userInfo.style.display = 'none';
            }
        }

function showStatsModal() {
    if (!currentUser) {
        alert('로그인이 필요한 서비스입니다.');
        return;
    }
    
    document.getElementById('statsModal').classList.remove('hidden');
    
    // 모든 그리드 초기화
    document.querySelectorAll('.stats-grid').forEach(grid => {
        grid.innerHTML = '';
    });
    
    generateStatsData();
}

function closeStatsModal() {
    document.getElementById('statsModal').classList.add('hidden');
}

function switchStatsTab(tabName) {
    // 모든 탭 비활성화
    document.querySelectorAll('.stats-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.stats-tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
   // 선택된 탭 활성화 - event.target 대신 다른 방법 사용
    document.querySelector(`[onclick="switchStatsTab('${tabName}')"]`).classList.add('active');
    document.getElementById(tabName + 'Stats').classList.add('active');
    
  // 해당 탭의 데이터 생성 (항상 새로 생성)
generateStatsDataForTab(tabName);
}

// 탭별 통계 데이터 생성
function generateStatsDataForTab(tabName) {
    let items = [];
    let correctData = {};
    let totalData = {};
    
    // 탭별 글자 목록 정의
    switch(tabName) {
        case 'consonants':
            items = ['ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            break;
        case 'doubleConsonants':
            items = ['ㄲ', 'ㄸ', 'ㅃ', 'ㅆ', 'ㅉ'];
            break;
        case 'vowels':
            items = ['ㅏ', 'ㅑ', 'ㅓ', 'ㅕ', 'ㅗ', 'ㅛ', 'ㅜ', 'ㅠ', 'ㅡ', 'ㅣ'];
            break;
        case 'doubleVowels':
            items = ['ㅐ', 'ㅒ', 'ㅔ', 'ㅖ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅢ'];
            break;
        case 'finals':
            items = ['ㄱ', 'ㄴ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ'];
            break;
        default:
            items = [];
    }
    
    // 사용자 데이터가 있으면 가져오기
    if (currentUser && currentUser.stats) {
        if (tabName === 'consonants' || tabName === 'doubleConsonants') {
            correctData = currentUser.stats.consonantCorrect || {};
            totalData = currentUser.stats.consonantTotal || {};
        } else if (tabName === 'vowels' || tabName === 'doubleVowels') {
            correctData = currentUser.stats.vowelCorrect || {};
            totalData = currentUser.stats.vowelTotal || {};
        } else if (tabName === 'finals') {
            correctData = currentUser.stats.finalCorrect || {};
            totalData = currentUser.stats.finalTotal || {};
        }
    }
    
    console.log(`${tabName} 탭 - 글자 수:`, items.length, '글자들:', items); // 디버깅용
    
    generateStatsGrid(tabName, items, correctData, totalData);
}

function generateStatsData() {
    // 항상 첫 번째 탭(자음) 데이터 생성 (사용자가 없어도)
    generateStatsDataForTab('consonants');
}

function generateStatsGrid(type, items, correctData, totalData) {
    const grid = document.getElementById('stats' + type.charAt(0).toUpperCase() + type.slice(1) + 'Grid');
    const practiceSection = document.getElementById('stats' + type.charAt(0).toUpperCase() + type.slice(1) + 'Practice');

    // null 체크 추가
    if (!grid) {
        console.error(`Required elements not found for type: ${type}`);
        return;
    }
    
    grid.innerHTML = '';
    
    // practiceSection이 있다면 숨기기
    if (practiceSection) {
        practiceSection.style.display = 'none';
    }
    
    items.forEach(item => {
        const correctCount = correctData[item] || 0;
        const totalCount = totalData[item] || 0;
        
      // 퍼센트 계산 (1회당 2%, 최대 100%)
const itemType = (type === 'consonants' || type === 'doubleConsonants') ? 'consonant' : 
                (type === 'vowels' || type === 'doubleVowels') ? 'vowel' : 'final';
const accuracy = calculatePercentage(item, itemType);
        
        const statItem = document.createElement('div');
        statItem.className = 'stat-item';
        
       // 정확도에 따른 클래스 설정 (더 엄격한 기준)
        if (totalCount === 0) {
            statItem.classList.add('no-data');
        } else if (accuracy >= 80) {
            statItem.classList.add('excellent');
        } else if (accuracy >= 60) {
            statItem.classList.add('good');
        } else if (accuracy >= 30) {
            statItem.classList.add('average');
        } else {
            statItem.classList.add('needs-practice');
        }
        
      // 실제 총 학습 횟수 가져오기
        const totalKey = itemType === 'consonant' ? 'consonantTotal' : 
                        itemType === 'vowel' ? 'vowelTotal' : 'finalTotal';
        const actualTotalCount = (currentUser.stats[totalKey] && currentUser.stats[totalKey][item]) || 0;
        
        // 학습 횟수 표시
        let statusText = '';
        if (actualTotalCount === 0) {
            statusText = '미학습';
        } else if (actualTotalCount < 10) {
            statusText = '초급';
        } else if (actualTotalCount < 25) {
            statusText = '중급';
        } else if (actualTotalCount < 40) {
            statusText = '고급';
        } else if (actualTotalCount >= 50) {
            statusText = '마스터';
        } else {
            statusText = '상급';
        }
        
        statItem.innerHTML = `
            <div class="stat-jamo">${item}</div>
            <div class="stat-bar">
                <div class="stat-fill" style="width: ${accuracy}%"></div>
            </div>
            <div class="stat-percentage">${accuracy}%</div>
        <div style="font-size: 10px; color: #666; margin-top: 5px;">
                ${statusText} (${actualTotalCount}회)
            </div>
        `;
        
        grid.appendChild(statItem);
    });
}

        let audioPlayback = null;
// 통합 음성 재생 함수 (모든 화면에서 사용)
function playUnifiedSound(sound, element = null) {
    console.log('통합 음성 재생:', sound);
    
    if (window.speechSynthesis.speaking) {
        window.speechSynthesis.cancel();
    }

    setTimeout(() => {
        const utterance = new SpeechSynthesisUtterance(sound);
        utterance.lang = 'ko-KR';
        
        if (sound === '그') {
            utterance.rate = 0.4;
            utterance.pitch = 0.8;
        } else if (sound === '크') {
            utterance.rate = 0.4;
            utterance.pitch = 1.4;
        } else if (sound === '드') {
            utterance.rate = 0.4;
            utterance.pitch = 0.8;
        } else if (sound === '트') {
            utterance.rate = 0.4;
            utterance.pitch = 1.4;
        } else if (sound === '즈') {
            utterance.rate = 0.4;
            utterance.pitch = 0.9;
        } else if (sound === '츠') {
            utterance.rate = 0.4;
            utterance.pitch = 1.3;
        } else if (sound === '브') {
            utterance.rate = 0.4;
            utterance.pitch = 0.8;
        } else if (sound === '프') {
            utterance.rate = 0.4;
            utterance.pitch = 1.5;
        } else if (sound === '윽') {
            utterance.rate = 0.2;
            utterance.pitch = 0.4;
            utterance.volume = 0.9;
        } else if (sound === '읃') {
               utterance.rate = 0.35;
            utterance.pitch = 1.2;
            utterance.volume = 1.0;
        } else if (sound === '으이') {
            utterance.rate = 1.2;
            utterance.pitch = 0.8;
            utterance.volume = 1.0;
 } else if (sound === '요') {
            utterance.rate = 0.6;
            utterance.pitch = 1.4;
            utterance.volume = 1.0;
        } else {
            utterance.rate = 0.8;
            utterance.pitch = 1.2;
        }
        
        utterance.volume = 1.0;

        if (element) {
            element.classList.add('playing');
            
            const cleanup = () => {
                element.classList.remove('playing');
            };
            
            utterance.onend = cleanup;
            utterance.onerror = cleanup;
            setTimeout(cleanup, 3000);
        }

        window.speechSynthesis.speak(utterance);
    }, 100);
}
                // 전역 변수
                let currentApp = null;
                let gameState = {
                    currentMode: 'noBatchim',
                    currentQuestionIndex: 0,
                    score: 0,
                    wrongAnswers: [],
                    isAnswered: false,
                    currentQuestion: null,
                    usedWords: [],
                    availableWords: []
                };
        
                // 화면 전환 함수들
                function showMainMenu() {
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('soundAnalysisScreen').classList.add('hidden');
    document.getElementById('gameScreen').classList.add('hidden');
    document.getElementById('jamoLearningScreen').classList.add('hidden');
    
    // 로그인 영역 표시
    document.querySelector('.login-area').style.display = 'flex';
    
  // 모든 음성 재생 완전히 중단
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
            // 한 번 더 확실히 중단
            setTimeout(() => {
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }
            }, 100);
        }
        
        // 게임의 오디오 재생 중단
        if (typeof stopAudioPlayback === 'function') {
            stopAudioPlayback();
        }

// 추가로 게임 관련 모든 음성 재생 중단
if (audioPlayback && audioPlayback.stop) {
    audioPlayback.stop();
    audioPlayback = null;
}
                    
                    // 소리 분석 앱 리셋
                    if (currentApp && currentApp.resetApp) {
                        currentApp.resetApp();
                    }
                }
       function showSoundAnalysis() {
    // 로그인 체크
    if (!currentUser) {
        alert('로그인이 필요한 서비스입니다. 먼저 로그인해주세요.');
        return;
    }
    
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('soundAnalysisScreen').classList.remove('hidden');
    document.getElementById('gameScreen').classList.add('hidden');
    document.getElementById('jamoLearningScreen').classList.add('hidden');
    
    // 로그인 영역 숨기기
    document.querySelector('.login-area').style.display = 'none';
                    
    // 소리 분석 앱 초기화
    if (!currentApp) {
        currentApp = new HangulPhonicsApp();
    }
}
        
             function showSoundGame() {
    // 로그인 체크
    if (!currentUser) {
        alert('로그인이 필요한 서비스입니다. 먼저 로그인해주세요.');
        return;
    }
    
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('soundAnalysisScreen').classList.add('hidden');
    document.getElementById('gameScreen').classList.remove('hidden');
    document.getElementById('jamoLearningScreen').classList.add('hidden');
    
    // 로그인 영역 숨기기
    document.querySelector('.login-area').style.display = 'none';
    
    // 게임 상태 완전 초기화
    gameState.currentQuestionIndex = 0;
    gameState.score = 0;
    gameState.wrongAnswers = [];
    gameState.isAnswered = false;
    gameState.currentQuestion = null;
    gameState.usedWords = [];
    gameState.availableWords = [];
    
    // UI 초기화
    document.getElementById('score').textContent = '0';
    document.getElementById('gameArea').style.display = 'block';
    document.getElementById('resultScreen').style.display = 'none';
    
    // 게임 시작
    displayQuestion();
    setTimeout(playAudio, 1000);
}
        
          function showJamoLearning() {
    // 로그인 체크
    if (!currentUser) {
        alert('로그인이 필요한 서비스입니다. 먼저 로그인해주세요.');
        return;
    }
    
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('soundAnalysisScreen').classList.add('hidden');
    document.getElementById('gameScreen').classList.add('hidden');
    document.getElementById('jamoLearningScreen').classList.remove('hidden');
    
    // 로그인 영역 숨기기
    document.querySelector('.login-area').style.display = 'none';
                    
    // 자음·모음 학습 초기화
    initializeJamoLearning();
}
        
                // 한글 파닉스 앱 클래스 (기존 코드)
                class HangulPhonicsApp {
                    constructor() {
                        this.recognition = null;
                        this.speechSynthesis = window.speechSynthesis;
                        this.currentSpeed = 0.6;
                        this.isPlaying = false;
                        this.currentData = null;
                        this.syllableGroups = [];
                        this.playingIndex = -1;
        
        this.isRecognizing = false;
            this.lastProcessedText = '';
            this.processingTimeout = null;
                        
                        this.initializeElements();
                        this.initializeEventListeners();
                        this.initializeSpeechRecognition();
                        this.checkMicrophonePermission();
                        
                        this.initializeHangulConstants();
// 모바일에서 페이지 visibility 변경 시 재생 중단 방지
if ('undefined' !== typeof document) {
    document.addEventListener('visibilitychange', () => {
        if (document.hidden && this.isPlaying) {
            // 백그라운드로 전환될 때 재생 중단
            console.log('페이지가 백그라운드로 전환되어 재생 중단');
            this.isPlaying = false;
            if (this.speechSynthesis.speaking) {
                this.speechSynthesis.cancel();
            }
        }
    });
}

// 모바일에서 음성 합성 중단 이벤트 감지
if ('speechSynthesis' in window) {
    // 음성 합성이 예기치 않게 중단될 때 처리
    const originalCancel = this.speechSynthesis.cancel.bind(this.speechSynthesis);
    this.speechSynthesis.cancel = () => {
        console.log('음성 재생 강제 중단됨');
        originalCancel();
    };
}
}
        
                    initializeHangulConstants() {
                        this.HANGUL_BASE = 0xAC00;
                        this.CONSONANT_COUNT = 19;
                        this.VOWEL_COUNT = 21;
                        this.FINAL_CONSONANT_COUNT = 28;
                        
                        this.INITIAL_CONSONANTS = [
                            'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ',
                            'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'
                        ];
                        
                        this.VOWELS = [
                            'ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ',
                            'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'
                        ];
                        
                        this.FINAL_CONSONANTS = [
                            '', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ',
                            'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'
                        ];
        
                        this.INITIAL_PRONUNCIATION_MAP = {
                            'ㄱ': '그', 'ㄲ': '끄', 'ㄴ': '느', 'ㄷ': '드', 'ㄸ': '뜨',
                            'ㄹ': '르', 'ㅁ': '므', 'ㅂ': '브', 'ㅃ': '쁘', 'ㅅ': '스',
                            'ㅆ': '쓰', 'ㅇ': ' ', 'ㅈ': '즈', 'ㅉ': '쯔', 'ㅊ': '츠',
                            'ㅋ': '크', 'ㅌ': '트', 'ㅍ': '프', 'ㅎ': '흐'
                        };
                        
                        this.VOWEL_PRONUNCIATION_MAP = {
                            'ㅏ': '아', 'ㅐ': '애', 'ㅑ': '야', 'ㅒ': '얘', 'ㅓ': '어',
                            'ㅔ': '에', 'ㅕ': '여', 'ㅖ': '예', 'ㅗ': '오', 'ㅘ': '와',
                            'ㅙ': '왜', 'ㅚ': '외', 'ㅛ': '요', 'ㅜ': '우', 'ㅝ': '워',
                            'ㅞ': '웨', 'ㅟ': '위', 'ㅠ': '유', 'ㅡ': '으', 'ㅢ': '으이', 'ㅣ': '이'
                        };
                        
                        this.FINAL_PRONUNCIATION_MAP = {
                            'ㄱ': '윽', 'ㄲ': '윽', 'ㄳ': '윽', 'ㅋ': '윽',
                            'ㄴ': '은', 'ㄵ': '은', 'ㄶ': '은',
                            'ㄷ': '읃', 'ㅅ': '읃', 'ㅆ': '읃', 'ㅈ': '읃', 
                            'ㅊ': '읃', 'ㅌ': '읃', 'ㅎ': '읃',
                            'ㄹ': '을', 'ㄺ': '윽', 'ㄻ': '음', 'ㄼ': '을', 
                            'ㄽ': '을', 'ㄾ': '을', 'ㄿ': '읍', 'ㅀ': '을',
                            'ㅁ': '음',
                            'ㅂ': '읍', 'ㅄ': '읍', 'ㅍ': '읍',
                            'ㅇ': '응'
                        };
                    }
        
                    initializeElements() {
                        this.micButton = document.getElementById('micButton');
                        this.voiceStatus = document.getElementById('voiceStatus');
                        this.loading = document.getElementById('loading');
                        this.resultSection = document.getElementById('resultSection');
                        this.originalText = document.getElementById('originalText');
                        this.phonicsGrid = document.getElementById('phonicsGrid');
                        this.playAllButton = document.getElementById('playAllButton');
                        this.speedSlider = document.getElementById('speedSlider');
                        this.speedDisplay = document.getElementById('speedDisplay');
                        this.resetButton = document.getElementById('resetButton');
                    }
        
                    initializeEventListeners() {
                        this.micButton.addEventListener('click', () => this.toggleRecording());
                        this.playAllButton.addEventListener('click', () => this.playAll());
                        this.speedSlider.addEventListener('input', (e) => this.updateSpeed(e.target.value));
                        this.resetButton.addEventListener('click', () => this.resetApp());
                    }
        
                    initializeSpeechRecognition() {
                        const SpeechRecognition = window.SpeechRecognition || 
                                                window.webkitSpeechRecognition || 
                                                window.mozSpeechRecognition ||
                                                window.msSpeechRecognition;
        
                        if (!SpeechRecognition) {
                            this.voiceStatus.textContent = '죄송해요, 이 브라우저는 음성인식을 지원하지 않아요';
                            this.micButton.disabled = true;
                            return;
                        }
        
                        this.recognition = new SpeechRecognition();
                        this.recognition.lang = 'ko-KR';
                        this.recognition.continuous = false;
                        this.recognition.interimResults = false;
                        this.recognition.maxAlternatives = 1;
        
                        this.recognition.onstart = () => {
                            this.micButton.classList.add('recording');
                            this.voiceStatus.textContent = '듣고 있어요... 단어를 말해보세요!';
        this.isRecognizing = true;
                        };
        
                        this.recognition.onresult = (event) => {
            if (!this.isRecognizing) return;
            
            if (event.results && event.results.length > 0) {
                const text = event.results[0][0].transcript.trim();
                
                if (text && text !== this.lastProcessedText) {
                    this.lastProcessedText = text;
                    this.isRecognizing = false;
                    this.micButton.classList.remove('recording');
                    
                    if (this.processingTimeout) {
                        clearTimeout(this.processingTimeout);
                    }
                    
                    this.processingTimeout = setTimeout(() => {
                        this.processVoiceInput(text);
                        this.processingTimeout = null;
                    }, 100);
                }
            }
        };
        
                        this.recognition.onerror = (event) => {
        this.isRecognizing = false;  // ← 이 줄을 추가
                            this.micButton.classList.remove('recording');
                            let errorMessage = '음성인식에 실패했어요. ';
                            switch(event.error) {
                                case 'not-allowed':
                                    errorMessage += '마이크 권한을 허용해주세요.';
                                    break;
                                case 'no-speech':
                                    errorMessage += '음성이 감지되지 않았어요.';
                                    break;
                                default:
                                    errorMessage += '다시 시도해주세요.';
                            }
                            this.voiceStatus.textContent = errorMessage;
                            setTimeout(() => {
                                if (!this.micButton.classList.contains('recording')) {
                                    this.voiceStatus.textContent = '마이크 버튼을 눌러 단어를 말해보세요';
                                }
                            }, 3000);
                        };
        
                        this.recognition.onend = () => {
        this.isRecognizing = false;  // ← 이 줄을 추가
                            this.micButton.classList.remove('recording');
                            if (this.voiceStatus.textContent.includes('듣고 있어요')) {
                                this.voiceStatus.textContent = '마이크 버튼을 눌러 단어를 말해보세요';
                            }
                        };
                    }
        
                    async checkMicrophonePermission() {
                        try {
                            if (navigator.permissions) {
                                const result = await navigator.permissions.query({ name: 'microphone' });
                                if (result.state === 'denied') {
                                    this.voiceStatus.textContent = '마이크 권한이 필요해요. 브라우저 설정에서 마이크를 허용해주세요.';
                                }
                            }
                        } catch (error) {
                            console.log('권한 확인 중 오류:', error);
                        }
                    }
        
                   toggleRecording() {
            if (!this.recognition) {
                alert('음성인식을 사용할 수 없습니다.');
                return;
            }
        
            if (this.micButton.classList.contains('recording') || this.isRecognizing) {
                // 인식 중단
                this.isRecognizing = false;
                this.recognition.stop();
                this.micButton.classList.remove('recording');
                this.voiceStatus.textContent = '마이크 버튼을 눌러 단어를 말해보세요';
            } else {
                // 인식 시작
                if (this.processingTimeout) {
                    clearTimeout(this.processingTimeout);
                    this.processingTimeout = null;
                }
                
                this.isRecognizing = true;
                this.lastProcessedText = '';
                
                try {
                    this.recognition.start();
                } catch (error) {
                    this.isRecognizing = false;
                    this.voiceStatus.textContent = '음성인식을 시작할 수 없어요. 다시 시도해주세요.';
                }
            }
        }
        
                    processVoiceInput(text) {
        if (this.isRecognizing) return;  // ← 이 줄을 추가
                        this.voiceStatus.textContent = `"${text}"를 분석중이에요...`;
                        this.loading.style.display = 'block';
                        setTimeout(() => {
                            this.analyzeHangul(text);
                            this.loading.style.display = 'none';
                        }, 500);
                    }
        
                     testWord(word) {
                        this.voiceStatus.textContent = `"${word}"를 분석중이에요...`;
                        this.loading.style.display = 'block';
                        setTimeout(() => {
                            this.analyzeHangul(word);
                            this.loading.style.display = 'none';
                        }, 500);
                    }
        
                    analyzeHangul(text) {
                        const hangulOnly = text.replace(/[^가-힣]/g, '');
                        
                        if (!hangulOnly) {
                            this.voiceStatus.textContent = '한글 단어를 말해주세요!';
                            return;
                        }
        
                        this.originalText.innerHTML = `<span class="emoji">💬</span> ${hangulOnly} <span class="emoji">💬</span>`;
                        
                        const syllableData = [];
                        for (let i = 0; i < hangulOnly.length; i++) {
                            const char = hangulOnly[i];
                            const decomposed = this.decompose(char);
                            if (decomposed) {
                                syllableData.push({
                                    original: char,
                                    ...decomposed
                                });
                            }
                        }
        
                        this.currentData = {
                            original: hangulOnly,
                            syllables: syllableData
                        };
        
                        this.displayPhonics(syllableData);
                        this.resultSection.classList.remove('hidden');
                        this.voiceStatus.textContent = '완성! 각 소리를 클릭해보세요 🎵';
                    }
        
                    decompose(char) {
                        const code = char.charCodeAt(0) - this.HANGUL_BASE;
                        if (code < 0 || code > 11171) return null;
        
                        const initialIndex = Math.floor(code / (this.VOWEL_COUNT * this.FINAL_CONSONANT_COUNT));
                        const vowelIndex = Math.floor((code % (this.VOWEL_COUNT * this.FINAL_CONSONANT_COUNT)) / this.FINAL_CONSONANT_COUNT);
                        const finalIndex = code % this.FINAL_CONSONANT_COUNT;
        
                        return {
                            initial: this.INITIAL_CONSONANTS[initialIndex],
                            vowel: this.VOWELS[vowelIndex],
                            final: finalIndex > 0 ? this.FINAL_CONSONANTS[finalIndex] : null
                        };
                    }
        
                    displayPhonics(syllableData) {
                        this.phonicsGrid.innerHTML = '';
                        this.syllableGroups = [];
        
                        syllableData.forEach((syllable) => {
                            const syllableGroup = document.createElement('div');
                            syllableGroup.className = 'syllable-group';
                            
                            const label = document.createElement('div');
                            label.className = 'syllable-label';
                            label.textContent = syllable.original;
                            syllableGroup.appendChild(label);
        
                            const phonicsContainer = document.createElement('div');
                            phonicsContainer.className = 'syllable-phonics';
        
                            const phonicsItems = [];
        
                         if (syllable.initial) {
            const pronunciation = this.INITIAL_PRONUNCIATION_MAP[syllable.initial] || syllable.initial;
            const initialItem = this.createPhonicsItem(
                syllable.initial, 
                pronunciation,
                'consonant',
                '자음'
            );
            phonicsContainer.appendChild(initialItem);
            phonicsItems.push(initialItem);
        }
        
                            if (syllable.vowel) {
                                const vowelItem = this.createPhonicsItem(
                                    syllable.vowel,
                                    this.VOWEL_PRONUNCIATION_MAP[syllable.vowel] || syllable.vowel,
                                    'vowel',
                                    '모음'
                                );
                                phonicsContainer.appendChild(vowelItem);
                                phonicsItems.push(vowelItem);
                            }
        
                            if (syllable.final) {
                                const finalItem = this.createPhonicsItem(
                                    syllable.final,
                                    this.FINAL_PRONUNCIATION_MAP[syllable.final] || syllable.final,
                                    'final',
                                    '받침'
                                );
                                phonicsContainer.appendChild(finalItem);
                                phonicsItems.push(finalItem);
                            }
        
                            syllableGroup.appendChild(phonicsContainer);
                            this.phonicsGrid.appendChild(syllableGroup);
                            
                            this.syllableGroups.push({
                                element: syllableGroup,
                                items: phonicsItems
                            });
                        });
                    }
        
                  createPhonicsItem(jamo, pronunciation, type, typeLabel) {
            const item = document.createElement('div');
            item.className = `phonics-item ${type}`;
            
            item.innerHTML = `
                <div class="jamo">${jamo}</div>
                <div class="pronunciation" style="display: none;">${pronunciation}</div>
                <div class="jamo-type ${type}">${typeLabel}</div>
            `;
        
                        item.addEventListener('click', () => {
                            this.playSound(pronunciation, item);
                        });
        
                        return item;
                    }
        
             playSound(text, element = null) {
    playUnifiedSound(text, element);
   // 소리 놀이에서는 단순 재생만 (통계 기록 안 함)
}
        
                 async playAll() {
    if (this.isPlaying || !this.currentData) return;

    this.isPlaying = true;
    this.playAllButton.disabled = true;
    this.playAllButton.textContent = '🎵 재생중...';

    try {
        // 모바일에서 더 짧은 대기 시간
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const baseDelay = isMobile ? 100 : 100;
        const wordDelay = isMobile ? 400 : 600;
        const jamoDelay = isMobile ? 200 : 400;
        const groupDelay = isMobile ? 200 : 300;
        
                   
                            await this.delay(100);
                            await this.playWithDelay(this.currentData.original, null, 800);
        
                            for (let i = 0; i < this.syllableGroups.length; i++) {
                                if (!this.isPlaying) break;
                                
                                const group = this.syllableGroups[i];
                                await this.playWithDelay(this.currentData.syllables[i].original, null, 600);
                                
                              for (let j = 0; j < group.items.length; j++) {
            if (!this.isPlaying) break;
            const item = group.items[j];
            const pronunciationElement = item.querySelector('.pronunciation');
            if (pronunciationElement) {
                const pronunciation = pronunciationElement.textContent;
                await this.playWithDelay(pronunciation, item, 400);
            }
        }
                                
                                if (i < this.syllableGroups.length - 1) {
                                    await this.delay(300);
                                }
                            }
        
                            if (this.isPlaying) {
                                await this.playWithDelay(this.currentData.original, null, 0);
                            }
        
                        } catch (error) {
                            console.error('재생 중 오류:', error);
                        } finally {
                            this.isPlaying = false;
                            this.playAllButton.disabled = false;
                            this.playAllButton.textContent = '▶️ 전체 재생';
                            
                            document.querySelectorAll('.phonics-item.playing').forEach(item => {
                                item.classList.remove('playing');
                            });
                        }
                    }
        
                   playWithDelay(text, element, delayMs) {
    return new Promise((resolve) => {
        if (this.speechSynthesis.speaking) {
            this.speechSynthesis.cancel();
        }
        
        // 모바일 안정성을 위한 짧은 대기 시간
        setTimeout(() => {
            // 재생 중단 체크
            if (!this.isPlaying) {
                resolve();
                return;
            }
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'ko-KR';
    
    // 기존의 utterance.rate = this.currentSpeed; 부분을 다음으로 교체
   if (text === '그') {
                utterance.rate = 0.4;
                utterance.pitch = 0.8;
            } else if (text === '크') {
                utterance.rate = 0.4;
                utterance.pitch = 1.4;
            } else if (text === '드') {
                utterance.rate = 0.4;
                utterance.pitch = 0.8;
            } else if (text === '트') {
                utterance.rate = 0.4;
                utterance.pitch = 1.4;
            } else if (text === '즈') {
                utterance.rate = 0.4;
                utterance.pitch = 0.9;
            } else if (text === '츠') {
                utterance.rate = 0.4;
                utterance.pitch = 1.3;
            } else if (text === '브') {
                utterance.rate = 0.4;
                utterance.pitch = 0.8;
            } else if (text === '프') {
                utterance.rate = 0.4;
                utterance.pitch = 1.5;
            } else if (text === '윽') {
                utterance.rate = 0.2;
                utterance.pitch = 0.4;
                utterance.volume = 0.9;
            } else if (text === '읃') {
                  utterance.rate = 0.35;
            utterance.pitch = 1.2;
            utterance.volume = 1.0;
            } else if (text === '으이') {
                utterance.rate = 1.2;
                utterance.pitch = 0.8;
                utterance.volume = 1.0;
 } else if (text === '요') {
            utterance.rate = 0.6;
            utterance.pitch = 1.4;
            utterance.volume = 1.0;
            } else {
                utterance.rate = this.currentSpeed;
                utterance.pitch = 1.2;
            }
            
            utterance.volume = 1.0;
            // 나머지 코드는 그대로 유지
            
            if (element) {
                element.classList.add('playing');
            }

            let isResolved = false;
            const resolveOnce = () => {
                if (!isResolved) {
                    isResolved = true;
                    if (element) {
                        element.classList.remove('playing');
                    }
                    setTimeout(resolve, delayMs);
                }
            };

            utterance.onend = resolveOnce;
            utterance.onerror = resolveOnce;

            const timeoutId = setTimeout(() => {
                this.speechSynthesis.cancel();
                resolveOnce();
            }, Math.max(text.length * 200, 2000));

            utterance.onstart = () => {
                clearTimeout(timeoutId);
            };

            this.speechSynthesis.speak(utterance);
        }, 50);
    });
}
        
                    delay(ms) {
                        return new Promise(resolve => setTimeout(resolve, ms));
                    }
        
                    updateSpeed(value) {
                        this.currentSpeed = parseFloat(value);
                        this.speedDisplay.textContent = `${value}x`;
                    }
        
                    resetApp() {
                        this.isPlaying = false;
                         this.isRecognizing = false;      // ← 추가
            this.lastProcessedText = '';     // ← 추가
            
            if (this.processingTimeout) {    // ← 추가 시작
                clearTimeout(this.processingTimeout);
                this.processingTimeout = null;
            }                                // ← 추가 끝
                        if (this.speechSynthesis.speaking) {
                            this.speechSynthesis.cancel();
                        }
                        
                        setTimeout(() => {
                            this.resultSection.classList.add('hidden');
                            this.voiceStatus.textContent = '마이크 버튼을 눌러 단어를 말해보세요';
                            this.currentData = null;
                            this.syllableGroups = [];
                            
                            this.playAllButton.disabled = false;
                            this.playAllButton.textContent = '▶️ 전체 재생';
                            
                            document.querySelectorAll('.phonics-item.playing').forEach(item => {
                                item.classList.remove('playing');
                            });
                        }, 100);
                    }
                }
        
                // 전역 함수로 testWord 노출
                function testWord(word) {
                    if (currentApp && currentApp.testWord) {
                        currentApp.testWord(word);
                    }
                }
        
                // 게임 관련 코드
                const INITIAL_PRONUNCIATION = {
                    'ㄱ': '그', 'ㄲ': '끄', 'ㄴ': '느', 'ㄷ': '드', 'ㄸ': '뜨',
                    'ㄹ': '르', 'ㅁ': '므', 'ㅂ': '브', 'ㅃ': '쁘', 'ㅅ': '스',
                    'ㅆ': '쓰', 'ㅇ': ' ', 'ㅈ': '즈', 'ㅉ': '쯔', 'ㅊ': '츠',
                    'ㅋ': '크', 'ㅌ': '트', 'ㅍ': '프', 'ㅎ': '흐'
                };
                
              const VOWEL_PRONUNCIATION = {
    'ㅏ': '아', 'ㅐ': '애', 'ㅑ': '야', 'ㅒ': '얘', 'ㅓ': '어',
    'ㅔ': '에', 'ㅕ': '여', 'ㅖ': '예', 'ㅗ': '오', 'ㅘ': '와',
    'ㅙ': '왜', 'ㅚ': '외', 'ㅛ': '요', 'ㅜ': '우', 'ㅝ': '워',
    'ㅞ': '웨', 'ㅟ': '위', 'ㅠ': '유', 'ㅡ': '으', 'ㅢ': '으이', 'ㅣ': '이'
};
                
                const FINAL_PRONUNCIATION = {
                    // 기본 받침 7개 (ㄱ,ㄴ,ㄹ,ㅁ,ㅂ,ㅅ,ㅇ)
                    'ㄱ': '윽',  // ㄱ 받침
                    'ㄴ': '은',   // ㄴ 받침
                    'ㄹ': '을',   // ㄹ 받침
                    'ㅁ': '음',   // ㅁ 받침
                    'ㅂ': '읍',   // ㅂ 받침
                    'ㅅ': '읃',   // ㅅ 받침
                    'ㅇ': '응',   // ㅇ 받침
                    
                    // 나머지 받침들 (게임용으로 유지)
                    'ㄲ': '윽', 'ㄳ': '윽', 'ㅋ': '윽',
                    'ㄵ': '은', 'ㄶ': '은',
                    'ㄷ': '읃', 'ㅆ': '읃', 'ㅈ': '읃', 
                    'ㅊ': '읃', 'ㅌ': '읃', 'ㅎ': '읃',
                    'ㄺ': '윽', 'ㄻ': '음', 'ㄼ': '을', 
                    'ㄽ': '을', 'ㄾ': '을', 'ㄿ': '읍', 'ㅀ': '을',
                    'ㅄ': '읍', 'ㅍ': '읍'
                };
        
                // 한글 자소 분해 함수
                function decomposeHangul(char) {
                    const code = char.charCodeAt(0) - 0xAC00;
                    if (code < 0 || code > 11171) return null;
        
                    const initial = Math.floor(code / 588);
                    const medial = Math.floor((code % 588) / 28);
                    const final = code % 28;
        
                    const initials = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
                    const medials = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
                    const finals = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
        
                    return {
                        initial: initials[initial],
                        medial: medials[medial],
                        final: finals[final]
                    };
                }
        
                // 단어를 파닉스로 분해 (디버깅 버전)
               function wordToPhonics(word) {
            const phonics = [];
            
            console.log('분해할 단어:', word);
            
            for (let char of word) {
                const decomposed = decomposeHangul(char);
                console.log(`${char} 분해 결과:`, decomposed);
                
                if (decomposed) {
                    // 음절별로 묶어서 처리
                    const syllablePhonics = [];
                    
                    // 초성 (자음)
                    const initialSound = INITIAL_PRONUNCIATION[decomposed.initial] || decomposed.initial;
                    syllablePhonics.push(initialSound);
                    
                    // 중성 (모음)
                    const vowelSound = VOWEL_PRONUNCIATION[decomposed.medial] || decomposed.medial;
                    syllablePhonics.push(vowelSound);
                    
                    // 종성 (받침) - 있는 경우에만
                    if (decomposed.final) {
                        const finalSound = FINAL_PRONUNCIATION[decomposed.final] || decomposed.final;
                        syllablePhonics.push(finalSound);
                    }
                    
                    // 음절 단위로 phonics 배열에 추가
                    phonics.push(...syllablePhonics);
                }
            }
            
            // 연속된 동일한 소리 제거
            const uniquePhonics = [];
            for (let i = 0; i < phonics.length; i++) {
                if (i === 0 || phonics[i] !== phonics[i-1]) {
                    uniquePhonics.push(phonics[i]);
                }
            }
            
            console.log('중복 제거 후 파닉스:', uniquePhonics);
            return uniquePhonics;
        }
        
                // 단어 데이터
              const noBatchimWordsWithIcons = [
    '나비', '여우', '개구리', '두더지', '하마', '메뚜기', '토끼', '코끼리', '사자', '돼지', '고래', '개미', '시소', '고추', 
    '사과', '바나나', '포도', '토마토', '체리', '우유', '치즈', '케이크', '고기', '거미', '사다리', '그네', '구두', '모기',
    '나무', '해', '비', '무지개', '귀', '코', '해파리', '해바라기', '허수아비', '고구마', '새우',
    '모자', '시계', '카메라', '비누', '의자', '자', '가위', '피자', '조개', '가오리', '게', '너구리', '타조', '주사기', '라디오',
    '버스', '기차', '배', '오토바이', '도토리', '가지', '배추', '부채', '기타', '피아노',
    '오리', '거위', '소', '크레파스', '파프리카', '튜브', '키위', '지구', '보라', '치마', '바지', '머리띠', 
];

const batchimWordsWithIcons = [
    '강아지', '고양이', '호랑이', '물고기', '상어', '문어', '돌고래', '부엉이',
    '닭', '말', '양', '기린', '원숭이', '팬더', '곰', '사슴', '도넛', '로봇',
    '다람쥐', '고슴도치', '박쥐', '펭귄', '캥거루', '참새', '브로콜리', '무당벌레', '꿀벌',
    '딸기', '사탕', '밥', '달걀', '빵', '떡', '아이스크림', '초콜릿','콩', '감', '당근', '밤',
    '바람','번개', '산', '전구', '풍선', '리본', '왕관', '버섯', '레몬',
    '신발', '거울', '가방', '책', '연필', '공책', '복숭아', '햄버거', '햄스터',
    '펜', '안경', '양말', '장갑', '우산', '새싹', '눈사람',
    '자전거', '트럭', '자동차', '비행기', '헬리콥터', '구급차', '잠자리', '경찰차',
    '빨강', '노랑', '파랑', '초록', '주황', '옥수수', '수박', '오징어', '애벌레',
    '얼굴', '눈', '입', '손', '발', '반지', '울타리', '거북이', '선인장',
    '집', '학교', '병원', '구름', '성', '별', '오렌지', '귀걸이', '앵무새'
];
        
     
const wordImageMap = {
    // 받침 없는 단어들
    '나비': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/butterfly.png.png',
    '여우': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/fox.png.png',
    '개구리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/frog.png.png',
    '두더지': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/mole.png.png',
    '하마': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/hippo.png.png',
    '메뚜기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/grasshopper.png.png',
    '토끼': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/rabbit.png.png',
    '코끼리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/elephant.png.png',
    '사자': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/lion.png.png',
    '돼지': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/pig.png.png',
    '고래': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/whale.png.png',
    '개미': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ant.png.png',
    '사과': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/apple.png.png',
    '바나나': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/banana.png.png',
    '포도': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/grape.png.png',
    '토마토': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/tomato.png.png',
    '체리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cherry.png.png',
    '우유': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/milk.png.png',
    '치즈': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cheese.png.png',
    '케이크': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cake.png.png',
    '고기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/meat.png.png',
    '거미': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/spider.png.png',
    '나무': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/tree.png.png',
    '해': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/sun.png.png',
    '비': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/rain.png.png',
    '무지개': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/rainbow.png.png',
    '귀': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ear.png.png',
    '코': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/nose.png.png',
    '해파리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/jellyfish.png.png',
    '해바라기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/sunflower.png.png',
    '허수아비': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/scarecrow.png.png',
    '고구마': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/sweet_potato.png.png',
    '모자': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/hat.png.png',
    '시계': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/clock.png.png',
    '카메라': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/camera.png.png',
    '비누': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/soap.png.png',
    '의자': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/chair.png.png',
    '자': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ruler.png.png',
    '가위': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/scissors.png.png',
    '피자': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/pizza.png.png',
    '조개': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/shell.png.png',
    '버스': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bus.png.png',
    '기차': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/train.png.png',
    '배': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ship.png.png',
    '오토바이': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/motorcycle.png.png',
    '도토리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/acorn.png.png',
    '가지': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/eggplant.png.png',
    '배추': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cabbage.png.png',
    '부채': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/fan.png.png',
    '기타': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/guitar.png.png',
    '피아노': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/piano.png.png',
    '오리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/duck.png.png',
    '거위': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/goose.png.png',
    '소': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cow.png.png',
    '크레파스': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/crayon.png.png',
    '파프리카': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/paprika.png.png',
    '튜브': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/tube.png.png',
    '키위': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/kiwi.png.png',
    '지구': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/earth.png.png',
    '보라': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/purple.png.png',
 '치마': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/skirt.png.png',
 '바지': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/pants.png.png',
 '머리띠': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/headband.png.png',
'가오리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/stingray.png',
'게': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/crab.png.png',
'너구리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/raccoon.png.png',
'타조': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ostrich.png.png',
'주사기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/syringe.png.png',
'라디오': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/radio.png.png',
'시소': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/seesaw.png.png',
'고추': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/chili.png',
'사다리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ladder.png.png',
'그네': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/swing.png.png',
'구두': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/heels.png.png',
'모기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/mosquito.png.png',
'새우': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/shrimp.png.png',





    
    

// 받침 있는 단어들
    '강아지': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/puppy.png.png',
    '고양이': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cat.png.png',
    '호랑이': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/tiger.png.png',
    '물고기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/fish.png.png',
    '상어': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/shark.png.png',
    '문어': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/octopus.png.png',
    '돌고래': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/dolphin.png.png',
    '부엉이': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/owl.png.png',
    '닭': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/chicken.png.png',
    '말': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/horse.png.png',
    '양': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/sheep.png.png',
    '기린': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/giraffe.png.png',
    '원숭이': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/monkey.png.png',
    '팬더': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/panda.png.png',
    '곰': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bear.png.png',
    '사슴': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/deer.png.png',
    '도넛': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/donut.png.png',
    '로봇': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/robot.png.png',
    '다람쥐': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/squirrel.png.png',
    '고슴도치': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/hedgehog.png.png',
    '박쥐': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bat.png.png',
    '펭귄': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/penguin.png.png',
    '캥거루': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/kangaroo.png.png',
    '참새': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/sparrow.png.png',
    '브로콜리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/broccoli.png.png',
    '무당벌레': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ladybug.png.png',
    '꿀벌': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bee.png.png',
    '딸기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/strawberry.png.png',
    '사탕': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/candy.png.png',
    '밥': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/rice.png.png',
    '달걀': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/egg.png.png',
    '빵': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bread.png.png',
    '떡': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/rice_cake.png.png',
    '아이스크림': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ice_cream.png.png',
    '초콜릿': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/chocolate.png.png',
    '콩': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bean.png.png',
    '감': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/persimmon.png.png',
    '당근': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/carrot.png.png',
    '밤': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/chestnut.png.png',
    '바람': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/wind.png.png',
    '번개': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/lightning.png.png',
    '산': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/mountain.png.png',
    '전구': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/light_bulb.png.png',
    '풍선': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/balloon.png.png',
    '리본': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ribbon.png.png',
    '왕관': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/crown.png.png',
    '버섯': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/mushroom.png.png',
    '레몬': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/lemon.png.png',
    '신발': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/shoes.png.png',
    '거울': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/mirror.png.png',
    '가방': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bag.png.png',
    '책': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/book.png.png',
    '연필': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/pencil.png.png',
    '공책': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/notebook.png.png',
    '복숭아': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/peach.png.png',
    '햄버거': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/hamburger.png.png',
    '햄스터': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/hamster.png.png',
    '펜': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/pen.png.png',
    '안경': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/glasses.png.png',
    '양말': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/socks.png.png',
    '장갑': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/gloves.png.png',
    '우산': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/umbrella.png.png',
    '새싹': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/sprout.png.png',
    '눈사람': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/snowman.png.png',
    '자전거': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/bicycle.png.png',
    '트럭': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/truck.png.png',
    '자동차': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/car.png.png',
    '비행기': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/airplane.png.png',
    '헬리콥터': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/helicopter.png.png',
    '구급차': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ambulance.png.png',
    '잠자리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/dragonfly.png.png',
    '경찰차': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/police_car.png.png',
    '빨강': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/red.png.png',
    '노랑': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/yellow.png.png',
    '파랑': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/blue.png.png',
    '초록': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/green.png.png',
    '주황': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/orange_color.png.png',
    '옥수수': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/corn.png.png',
    '수박': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/watermelon.png.png',
    '오징어': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/squid.png.png',
    '애벌레': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/caterpillar.png.png',
    '얼굴': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/face.png.png',
    '눈': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/eye.png.png',
    '입': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/mouth.png.png',
    '손': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/hand.png.png',
    '발': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/foot.png.png',
    '반지': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/ring.png.png',
    '울타리': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/fence.png.png',
    '거북이': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/turtle.png.png',
    '선인장': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cactus.png.png',
    '집': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/house.png.png',
    '학교': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/school.png.png',
    '병원': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/hospital.png.png',
    '구름': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/cloud.png.png',
    '성': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/castle.png.png',
    '별': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/star.png.png',
    '오렌지': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/orange_fruit.png.png',
    '귀걸이': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/earrings.png.png',
    '앵무새': 'https://raw.githubusercontent.com/minkyeong1128/phonics-images/main/images/parrot.png.png'
};
        
         function loadImageForWord(word) {
    const wordImageContainer = document.getElementById('wordImage');
    const imageUrl = wordImageMap[word];
    
    // 완전히 초기화
    wordImageContainer.innerHTML = '';
    wordImageContainer.style.cssText = '';
    
    if (imageUrl) {
        // 실제 이미지 로드
        const img = document.createElement('img');
        
        // 로딩 표시 먼저 보여주기
        const loadingDiv = document.createElement('div');
        loadingDiv.textContent = '로딩중...';
        loadingDiv.style.cssText = `
            font-size: 18px !important;
            color: #666 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            height: 100% !important;
        `;
        wordImageContainer.appendChild(loadingDiv);
        
        // 이미지 로드 성공 시
        img.onload = function() {
            wordImageContainer.innerHTML = ''; // 로딩 메시지 제거
            wordImageContainer.appendChild(img);
        };
        
        // 이미지 로드 실패 시 기본 이모지 표시
        img.onerror = function() {
            console.warn(`이미지 로드 실패: ${word} - ${imageUrl}`);
            wordImageContainer.innerHTML = '';
            
            const fallbackDiv = document.createElement('div');
            fallbackDiv.textContent = '🖼️';
            fallbackDiv.style.cssText = `
                font-size: 4em !important;
                color: #5a67d8 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                height: 100% !important;
                text-decoration: none !important;
            `;
            wordImageContainer.appendChild(fallbackDiv);
        };
        
        // 이미지 속성 설정
        img.setAttribute('style', `
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            border-radius: 12px !important;
            background: transparent !important;
            text-decoration: none !important;
            border: none !important;
            outline: none !important;
            display: block !important;
        `);
        
        img.src = imageUrl;
        img.alt = word;
        
    } else {
        // 이미지 URL이 없을 때 기본 표시
        console.warn(`이미지 URL을 찾을 수 없음: ${word}`);
        const fallbackDiv = document.createElement('div');
        fallbackDiv.textContent = '❓';
        fallbackDiv.style.cssText = `
            font-size: 4em !important;
            color: #5a67d8 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            height: 100% !important;
            text-decoration: none !important;
        `;
        wordImageContainer.appendChild(fallbackDiv);
    }
}
        
                function playCorrectSound() {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                    } catch (error) {
                        console.log('오디오 재생 실패:', error);
                    }
                }
        
                function playIncorrectSound() {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(250, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(200, audioContext.currentTime + 0.2);
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.4);
                    } catch (error) {
                        console.log('오디오 재생 실패:', error);
                    }
                }
        
                function generateRandomChoices(correctAnswer, wordPool) {
                    const choices = [correctAnswer];
                    const correctSyllableCount = correctAnswer.length;
                    
                    const availableWords = wordPool.filter(word => 
                        word !== correctAnswer && word.length === correctSyllableCount
                    );
                    
                    const finalWordPool = availableWords.length >= 2 ? availableWords : 
                                         wordPool.filter(word => word !== correctAnswer);
                    
                    while (choices.length < 3) {
                        const randomWord = finalWordPool[Math.floor(Math.random() * finalWordPool.length)];
                        if (!choices.includes(randomWord)) {
                            choices.push(randomWord);
                        }
                    }
                    
                    return choices.sort(() => Math.random() - 0.5);
                }
        
                function generateNewQuestion() {
                    if (gameState.availableWords.length === 0) {
                        const wordPool = gameState.currentMode === 'noBatchim' ? noBatchimWordsWithIcons : batchimWordsWithIcons;
                        gameState.availableWords = [...wordPool];
                    }
                    
                    const randomIndex = Math.floor(Math.random() * gameState.availableWords.length);
                    const correctWord = gameState.availableWords.splice(randomIndex, 1)[0];
                    
                    gameState.usedWords.push(correctWord);
                    
                    const wordPool = gameState.currentMode === 'noBatchim' ? noBatchimWordsWithIcons : batchimWordsWithIcons;
                    const choices = generateRandomChoices(correctWord, wordPool);
                    
                    return {
                        word: correctWord,
                        choices: choices,
                        correct: choices.indexOf(correctWord)
                    };
                }
        
                function setMode(mode) {
                    gameState.currentMode = mode;
                    document.getElementById('noBatchimMode').classList.toggle('active', mode === 'noBatchim');
                    document.getElementById('batchimMode').classList.toggle('active', mode === 'batchim');
        
                    gameState.usedWords = [];
                    gameState.availableWords = [];
        
                    restartGame();
                }
        
                function playAudio() {
            if (!gameState.currentQuestion) return;
        
            // 기존 재생 중단
            stopAudioPlayback();
        
            const phonics = wordToPhonics(gameState.currentQuestion.word);
            console.log('재생할 파닉스:', phonics);
            
            const uniquePhonics = [];
            for (let i = 0; i < phonics.length; i++) {
                if (i === 0 || phonics[i] !== phonics[i-1]) {
                    uniquePhonics.push(phonics[i]);
                }
            }
            
            console.log('중복 제거 후:', uniquePhonics);
            
            let index = 0;
            let isStopped = false;
        
            function playNext() {
                if (index >= uniquePhonics.length || isStopped) return;
        
             const utterance = new SpeechSynthesisUtterance(uniquePhonics[index]);
utterance.lang = 'ko-KR';

  const sound = uniquePhonics[index];
        if (sound === '그') {
            utterance.rate = 0.4;
            utterance.pitch = 0.8;
        } else if (sound === '크') {
            utterance.rate = 0.4;
            utterance.pitch = 1.4;
        } else if (sound === '드') {
            utterance.rate = 0.4;
            utterance.pitch = 0.8;
        } else if (sound === '트') {
            utterance.rate = 0.4;
            utterance.pitch = 1.4;
        } else if (sound === '즈') {
            utterance.rate = 0.4;
            utterance.pitch = 0.9;
        } else if (sound === '츠') {
            utterance.rate = 0.4;
            utterance.pitch = 1.3;
        } else if (sound === '브') {
            utterance.rate = 0.4;
            utterance.pitch = 0.8;
        } else if (sound === '프') {
            utterance.rate = 0.4;
            utterance.pitch = 1.5;
        } else if (sound === '윽') {
            utterance.rate = 0.2;
            utterance.pitch = 0.4;
            utterance.volume = 0.9;
        } else if (sound === '읃') {
             utterance.rate = 0.35;
            utterance.pitch = 1.2;
            utterance.volume = 1.0;
        } else if (sound === '으이') {
            utterance.rate = 1.2;
            utterance.pitch = 0.8;
            utterance.volume = 1.0;
 } else if (sound === '요') {
            utterance.rate = 0.6;
            utterance.pitch = 1.4;
            utterance.volume = 1.0;
        } else {
            utterance.rate = 0.5;
            utterance.pitch = 1.2;
        }

        utterance.volume = 1.0;
        
        utterance.onend = function() {
            index++;
            if (index < uniquePhonics.length && !isStopped) {
                setTimeout(playNext, 400);
            }
        };

        utterance.onerror = function() {
            console.log('음성 재생 오류');
            index++;
            if (index < uniquePhonics.length && !isStopped) {
                setTimeout(playNext, 400);
            }
        };

        window.speechSynthesis.speak(utterance);
    }

    audioPlayback = {
        stop: function() {
            isStopped = true;
            window.speechSynthesis.cancel();
        }
    };

    setTimeout(playNext, 100);
}
        function stopAudioPlayback() {
            if (audioPlayback && audioPlayback.stop) {
                audioPlayback.stop();
                audioPlayback = null;
            }
            window.speechSynthesis.cancel();
        }
        
                function displayQuestion() {
                    gameState.currentQuestion = generateNewQuestion();
        
                    document.getElementById('currentQuestion').textContent = gameState.currentQuestionIndex + 1;
                    
                    loadImageForWord(gameState.currentQuestion.word);
        
                    const choicesContainer = document.getElementById('choices');
                    choicesContainer.innerHTML = '';
        
                    gameState.currentQuestion.choices.forEach((choice, index) => {
                        const button = document.createElement('button');
                        button.className = 'choice-button';
                        button.textContent = choice;
                        button.onclick = () => selectAnswer(index);
                        choicesContainer.appendChild(button);
                    });
        
                    document.getElementById('feedback').classList.add('hidden');
                    document.getElementById('nextButton').classList.add('hidden');
                    gameState.isAnswered = false;

setTimeout(() => {
    playAudio();
}, 1000);
                }
        
                function selectAnswer(selectedIndex) {
                    if (gameState.isAnswered) return;
                    
                // 파닉스 재생 완전히 중단
        stopAudioPlayback();
        
        // 짧은 대기 후 완전히 중단되었는지 확인
        setTimeout(() => {
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
        }, 50);
        
        // 선택한 보기의 소리 재생
        setTimeout(() => {
            const selectedWord = gameState.currentQuestion.choices[selectedIndex];
            const utterance = new SpeechSynthesisUtterance(selectedWord);
            utterance.lang = 'ko-KR';
            utterance.rate = 0.8;
            utterance.volume = 1.0;
            utterance.pitch = 1.0;
            window.speechSynthesis.speak(utterance);
        }, 200);
                    
                    gameState.isAnswered = true;
        
                    const correctIndex = gameState.currentQuestion.choices.indexOf(gameState.currentQuestion.word);
                    const buttons = document.querySelectorAll('.choice-button');
                    const feedback = document.getElementById('feedback');
        
                    buttons.forEach(btn => btn.style.pointerEvents = 'none');
        
                    if (selectedIndex === correctIndex) {
                        gameState.score++;
                        document.getElementById('score').textContent = gameState.score;
// 통계 업데이트
if (currentUser) {
    updateGameStats(gameState.currentQuestion.word, true);
}
        
                        buttons[selectedIndex].classList.add('correct');
                        feedback.className = 'feedback correct';
                        feedback.innerHTML = `<strong>정답입니다! 🎉</strong><br>정답: ${gameState.currentQuestion.word}`;
                        feedback.classList.remove('hidden');
                        
                        playCorrectSound();
                    } else {
                        buttons.forEach((btn, index) => {
                            if (index === correctIndex) {
                                btn.classList.add('correct');
                            } else {
                                btn.classList.add('incorrect');
                            }
                        });
       
 // 통계 업데이트
if (currentUser) {
    updateGameStats(gameState.currentQuestion.word, false);
}

                        gameState.wrongAnswers.push({
                            question: gameState.currentQuestionIndex + 1,
                            word: gameState.currentQuestion.word,
                            userAnswer: gameState.currentQuestion.choices[selectedIndex],
                            correctAnswer: gameState.currentQuestion.word
                        });
        
                        feedback.className = 'feedback incorrect';
                        feedback.innerHTML = `<strong>틀렸습니다! 😅</strong><br>정답: ${gameState.currentQuestion.word}`;
                        feedback.classList.remove('hidden');
                        
                        playIncorrectSound();
                    }
        
                    document.getElementById('nextButton').classList.remove('hidden');
                }
        
                function nextQuestion() {
                    gameState.currentQuestionIndex++;
                    
                    if (gameState.currentQuestionIndex >= 10) {
                        showResult();
                    } else {
                        displayQuestion();
                    }
                }
        
                function showResult() {
                    document.getElementById('gameArea').style.display = 'none';
                    document.getElementById('resultScreen').style.display = 'block';
        
                    const totalQuestions = 10;
                    const correctAnswers = gameState.score;
                    const percentage = Math.round((correctAnswers / totalQuestions) * 100);
                    
                    let message = '';
                    if (percentage === 100) {
                        message = '🎉 완벽해요! 모든 문제를 맞췄어요! 🎉';
                    } else if (percentage >= 80) {
                        message = '🌟 훌륭해요! 정말 잘했어요! 🌟';
                    } else if (percentage >= 60) {
                        message = '👍 좋아요! 조금만 더 연습하면 더 잘할 수 있어요! 👍';
                    } else {
                        message = '💪 괜찮아요! 다시 도전해보세요! 💪';
                    }
                    
                    document.getElementById('finalScore').innerHTML = `
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 1.1em; margin-bottom: 10px;">
                                총 <span style="color: #ff6b6b;">${totalQuestions}</span>문제 중 
                                <span style="color: #ff6b6b;">${correctAnswers}</span>문제 정답!
                            </div>
                            <div style="font-size: 1.5em; color: #ff6b6b;">
                                최종 점수: ${gameState.score}점
                            </div>
                            <div style="font-size: 1.1em; margin-top: 20px; color: #000000;">
                                ${message}
                            </div>
                        </div>
                    `;
        
                    const wrongAnswersContainer = document.getElementById('wrongAnswers');
                    wrongAnswersContainer.style.display = 'none';
                }
        
                function restartGame() {
                    gameState.currentQuestionIndex = 0;
                    gameState.score = 0;
                    gameState.wrongAnswers = [];
                    gameState.isAnswered = false;
                    gameState.currentQuestion = null;
                    gameState.usedWords = [];
                    gameState.availableWords = [];
        
                    document.getElementById('score').textContent = '0';
                    document.getElementById('gameArea').style.display = 'block';
                    document.getElementById('resultScreen').style.display = 'none';

// 추가: 혹시 숨겨져 있을 수 있는 피드백과 다음 버튼도 초기화
    document.getElementById('feedback').classList.add('hidden');
    document.getElementById('nextButton').classList.add('hidden');
        
                    displayQuestion();
                }
        
             function initializeGame() {
    // 게임 상태 완전 초기화
    gameState.currentQuestionIndex = 0;
    gameState.score = 0;
    gameState.wrongAnswers = [];
    gameState.isAnswered = false;
    gameState.currentQuestion = null;
    gameState.usedWords = [];
    gameState.availableWords = [];
    
    // UI 초기화
    document.getElementById('score').textContent = '0';
    document.getElementById('gameArea').style.display = 'block';
    document.getElementById('resultScreen').style.display = 'none';
    
    displayQuestion();
    setTimeout(playAudio, 1000);
}
        
                // 앱 시작 시 메인 메뉴 표시
                window.onload = function() {
                    showMainMenu();
                };
        
               // 획순 데이터 정의
        
        // 각 자모별 개별 조정값 (크기, 위치)
        const STROKE_ADJUSTMENTS = {
            'ㄱ': { scaleX: 1.4, scaleY: 1.0, offsetX: 20, offsetY: -10 },
            'ㄴ': { scaleX: 1.4, scaleY: 1.0, offsetX: 0, offsetY: -13 },
            'ㄷ': { scaleX: 1.1, scaleY: 1.0, offsetX: 10, offsetY: -10 },  
            'ㄹ': { scaleX: 1.2, scaleY: 1.0, offsetX: 30, offsetY: 0 },  
            'ㅁ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: -10 },
            'ㅂ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: -10 },
            'ㅅ': { scaleX: 1.1, scaleY: 1.0, offsetX: -10, offsetY: 0 },
            'ㅇ': { scaleX: 1.1, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅈ': { scaleX: 1.3, scaleY: 1.0, offsetX: 0, offsetY: -10 },
            'ㅊ': { scaleX: 1.4, scaleY: 1.0, offsetX: 15, offsetY: 0 },
            'ㅋ': { scaleX: 1.4, scaleY: 1.0, offsetX: 20, offsetY: -10 },
            'ㅌ': { scaleX: 1.1, scaleY: 1.0, offsetX: 10, offsetY: -10 },
            'ㅍ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: -10 },
            'ㅎ': { scaleX: 1.0, scaleY: 1.0, offsetX: 20, offsetY: -15 },
            
            // 모음
            'ㅏ': { scaleX: 1.4, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅑ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅓ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅕ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅗ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅛ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅜ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅠ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
            'ㅡ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
           'ㅣ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        
        // 쌍자음 조정값
        'ㄲ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: -10 },
        'ㄸ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: -10 },
        'ㅃ': { scaleX: 0.9, scaleY: 1.0, offsetX: 0, offsetY: -10 },
        'ㅆ': { scaleX: 0.8, scaleY: 1.0, offsetX: -10, offsetY: 0 },
        'ㅉ': { scaleX: 1.1, scaleY: 1.0, offsetX: 0, offsetY: -10 },
        
        // 이중모음 조정값
        'ㅐ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅒ': { scaleX: 0.9, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅔ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅖ': { scaleX: 0.9, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅘ': { scaleX: 0.8, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅙ': { scaleX: 0.7, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅚ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅝ': { scaleX: 0.8, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅞ': { scaleX: 0.7, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅟ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 },
        'ㅢ': { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 }
        };
        
        // 기본값 (조정값이 없는 자모용)
        const DEFAULT_ADJUSTMENT = { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 };
        const STROKE_ORDER = {
            'ㄱ': [
                [{ type: 'line', start: [0.2, 0.3], end: [0.6, 0.3] }, { type: 'line', start: [0.6, 0.3], end: [0.6, 0.7] }]  // 1획: 가로+세로 연결
            ],
            'ㄴ': [
                [{ type: 'line', start: [0.3, 0.2], end: [0.3, 0.7] }, { type: 'line', start: [0.3, 0.7], end: [0.7, 0.7] }]  // 1획: 세로+가로 연결
            ],
            'ㄷ': [
                [{ type: 'line', start: [0.2, 0.3], end: [0.7, 0.3] }],  // 1획: 위쪽 가로획
                [{ type: 'line', start: [0.2, 0.3], end: [0.2, 0.7] }, { type: 'line', start: [0.2, 0.7], end: [0.7, 0.7] }]  // 2획: 세로+가로 연결
            ],
         'ㄹ': [
            [{ type: 'line', start: [0.15, 0.25], end: [0.6, 0.25] }, { type: 'line', start: [0.6, 0.25], end: [0.6, 0.45] }],  // 1획: 가로+세로
            [{ type: 'line', start: [0.15, 0.45], end: [0.6, 0.45] }],  // 2획: 가로획
            [{ type: 'line', start: [0.15, 0.45], end: [0.15, 0.65] }, { type: 'line', start: [0.15, 0.65], end: [0.6, 0.65] }]  // 3획: 세로+가로 (0.7→0.65로 단축)
        ],
          'ㅁ': [
            [{ type: 'line', start: [0.25, 0.3], end: [0.25, 0.7] }],  // 1획: 왼쪽 세로획 (0.25→0.3, 0.75→0.7)
            [{ type: 'line', start: [0.25, 0.3], end: [0.75, 0.3] }, { type: 'line', start: [0.75, 0.3], end: [0.75, 0.7] }],  // 2획: 가로+세로 (0.25→0.3, 0.75→0.7)
            [{ type: 'line', start: [0.25, 0.7], end: [0.75, 0.7] }]  // 3획: 아래 가로획 (0.75→0.7)
        ],
           'ㅂ': [
            [{ type: 'line', start: [0.25, 0.3], end: [0.25, 0.7] }],   // 1획: 왼쪽 세로획 (0.25→0.3, 0.75→0.7)
            [{ type: 'line', start: [0.75, 0.3], end: [0.75, 0.7] }],   // 2획: 오른쪽 세로획 (0.25→0.3, 0.75→0.7)
            [{ type: 'line', start: [0.25, 0.45], end: [0.75, 0.45] }], // 3획: 가운데 가로획 (0.5→0.45)
            [{ type: 'line', start: [0.25, 0.7], end: [0.75, 0.7] }]    // 4획: 아래 가로획 (0.75→0.7)
        ],
        'ㅅ': [
            [{ type: 'line', start: [0.6, 0.3], end: [0.3, 0.7] }],     // 1획: 오른쪽 대각선 (그대로 유지)
            [{ type: 'line', start: [0.53, 0.4], end: [0.8, 0.66] }]    // 2획: 왼쪽 대각선 (조금 더 이동 + 길이 연장)
        ],
            'ㅇ': [
                [{ type: 'circle', center: [0.5, 0.5], radius: 0.2 }]       // 1획: 원
            ],
           'ㅈ': [
            [{ type: 'line', start: [0.2, 0.3], end: [0.6, 0.3] }, { type: 'line', start: [0.6, 0.3], end: [0.3, 0.7] }],  // 1획: 가로+대각선
            [{ type: 'line', start: [0.45, 0.5], end: [0.7, 0.65] }]    // 2획: 오른쪽 대각선 (길이 단축)
        ],
          'ㅊ': [
            [{ type: 'line', start: [0.3, 0.25], end: [0.5, 0.25] }],   // 1획: 짧은 가로줄
            [{ type: 'line', start: [0.2, 0.35], end: [0.6, 0.35] }, { type: 'line', start: [0.6, 0.35], end: [0.3, 0.7] }],  // 2획: 가로+대각선
            [{ type: 'line', start: [0.45, 0.525], end: [0.65, 0.7] }]  // 3획: 오른쪽 대각선 (길이 단축)
        ],
            'ㅋ': [
                [{ type: 'line', start: [0.2, 0.3], end: [0.6, 0.3] }, { type: 'line', start: [0.6, 0.3], end: [0.6, 0.7] }],  // 1획: 가로+세로
                [{ type: 'line', start: [0.2, 0.5], end: [0.6, 0.5] }]      // 2획: 가운데 가로획
            ],
         'ㅌ': [
            [{ type: 'line', start: [0.2, 0.3], end: [0.7, 0.3] }],     // 1획: 위 가로획
            [{ type: 'line', start: [0.2, 0.5], end: [0.7, 0.5] }],     // 2획: 가운데 가로획
            [{ type: 'line', start: [0.2, 0.3], end: [0.2, 0.7] }, { type: 'line', start: [0.2, 0.7], end: [0.7, 0.7] }]   // 3획: 세로+아래 가로
        ],
            'ㅍ': [
                [{ type: 'line', start: [0.2, 0.3], end: [0.8, 0.3] }],     // 1획: 위 가로획
                [{ type: 'line', start: [0.35, 0.3], end: [0.35, 0.7] }],   // 2획: 왼쪽 세로획
                [{ type: 'line', start: [0.65, 0.3], end: [0.65, 0.7] }],   // 3획: 오른쪽 세로획
                [{ type: 'line', start: [0.2, 0.7], end: [0.8, 0.7] }]      // 4획: 아래 가로획
            ],
        'ㅎ': [
            [{ type: 'line', start: [0.3, 0.25], end: [0.5, 0.25] }],   // 1획: 짧은 가로줄 (길이 단축)
            [{ type: 'line', start: [0.15, 0.35], end: [0.65, 0.35] }], // 2획: 긴 가로줄
            [{ type: 'circle', center: [0.4, 0.6], radius: 0.15 }]      // 3획: 원
        ],    
            // 모음
            'ㅏ': [
                [{ type: 'line', start: [0.5, 0.2], end: [0.5, 0.8] }],     // 1획: 긴 세로줄
                [{ type: 'line', start: [0.5, 0.5], end: [0.7, 0.5] }]      // 2획: 짧은 가로줄
            ],
           'ㅑ': [
            [{ type: 'line', start: [0.5, 0.2], end: [0.5, 0.8] }],     // 1획: 긴 세로줄
            [{ type: 'line', start: [0.5, 0.42], end: [0.7, 0.42] }],   // 2획: 위 가로줄 (0.45→0.42)
            [{ type: 'line', start: [0.5, 0.58], end: [0.7, 0.58] }]    // 3획: 아래 가로줄 (0.55→0.58)
        ],
            'ㅓ': [
                [{ type: 'line', start: [0.3, 0.5], end: [0.5, 0.5] }],     // 1획: 짧은 가로줄
                [{ type: 'line', start: [0.5, 0.2], end: [0.5, 0.8] }]      // 2획: 긴 세로줄
            ],
           'ㅕ': [
            [{ type: 'line', start: [0.3, 0.42], end: [0.5, 0.42] }],   // 1획: 위 가로줄 (0.45→0.42)
            [{ type: 'line', start: [0.3, 0.58], end: [0.5, 0.58] }],   // 2획: 아래 가로줄 (0.55→0.58)
            [{ type: 'line', start: [0.5, 0.2], end: [0.5, 0.8] }]      // 3획: 긴 세로줄
        ],
            'ㅗ': [
                [{ type: 'line', start: [0.5, 0.3], end: [0.5, 0.45] }],    // 1획: 짧은 세로줄
                [{ type: 'line', start: [0.2, 0.45], end: [0.8, 0.45] }]    // 2획: 긴 가로줄
            ],
           'ㅛ': [
            [{ type: 'line', start: [0.42, 0.3], end: [0.42, 0.45] }],  // 1획: 왼쪽 세로줄 (0.45→0.42)
            [{ type: 'line', start: [0.58, 0.3], end: [0.58, 0.45] }],  // 2획: 오른쪽 세로줄 (0.55→0.58)
            [{ type: 'line', start: [0.2, 0.45], end: [0.8, 0.45] }]    // 3획: 긴 가로줄
        ],
            'ㅜ': [
                [{ type: 'line', start: [0.2, 0.55], end: [0.8, 0.55] }],   // 1획: 긴 가로줄
                [{ type: 'line', start: [0.5, 0.55], end: [0.5, 0.7] }]     // 2획: 짧은 세로줄
            ],
            'ㅠ': [
                [{ type: 'line', start: [0.2, 0.55], end: [0.8, 0.55] }],   // 1획: 긴 가로줄
                [{ type: 'line', start: [0.4, 0.55], end: [0.4, 0.7] }],    // 2획: 왼쪽 세로줄
                [{ type: 'line', start: [0.6, 0.55], end: [0.6, 0.7] }]     // 3획: 오른쪽 세로줄
            ],
            'ㅡ': [
                [{ type: 'line', start: [0.2, 0.5], end: [0.8, 0.5] }]      // 1획: 긴 가로줄
            ],
         'ㅣ': [
            [{ type: 'line', start: [0.5, 0.2], end: [0.5, 0.8] }]      // 1획: 긴 세로줄
        ],
        
        // 쌍자음 (기본 자음 2번 반복)
        'ㄲ': [
            [{ type: 'line', start: [0.15, 0.3], end: [0.45, 0.3] }, { type: 'line', start: [0.45, 0.3], end: [0.45, 0.7] }],  // 1획: 첫 번째 ㄱ
            [{ type: 'line', start: [0.55, 0.3], end: [0.85, 0.3] }, { type: 'line', start: [0.85, 0.3], end: [0.85, 0.7] }]   // 2획: 두 번째 ㄱ
        ],
        'ㄸ': [
            [{ type: 'line', start: [0.15, 0.3], end: [0.45, 0.3] }],  // 1획: 첫 번째 ㄷ 위쪽 가로획
            [{ type: 'line', start: [0.15, 0.3], end: [0.15, 0.7] }, { type: 'line', start: [0.15, 0.7], end: [0.45, 0.7] }],  // 2획: 첫 번째 ㄷ 세로+가로
            [{ type: 'line', start: [0.55, 0.3], end: [0.85, 0.3] }],  // 3획: 두 번째 ㄷ 위쪽 가로획
            [{ type: 'line', start: [0.55, 0.3], end: [0.55, 0.7] }, { type: 'line', start: [0.55, 0.7], end: [0.85, 0.7] }]   // 4획: 두 번째 ㄷ 세로+가로
        ],
        'ㅃ': [
            [{ type: 'line', start: [0.16, 0.3], end: [0.16, 0.7] }],   // 1획: 첫 번째 ㅂ 왼쪽 세로획 (0.18→0.16)
            [{ type: 'line', start: [0.39, 0.3], end: [0.39, 0.7] }],   // 2획: 첫 번째 ㅂ 오른쪽 세로획 (0.37→0.39)
            [{ type: 'line', start: [0.16, 0.45], end: [0.39, 0.45] }], // 3획: 첫 번째 ㅂ 가운데 가로획
            [{ type: 'line', start: [0.16, 0.7], end: [0.39, 0.7] }],   // 4획: 첫 번째 ㅂ 아래 가로획
            [{ type: 'line', start: [0.61, 0.3], end: [0.61, 0.7] }],   // 5획: 두 번째 ㅂ 왼쪽 세로획 (0.63→0.61)
            [{ type: 'line', start: [0.84, 0.3], end: [0.84, 0.7] }],   // 6획: 두 번째 ㅂ 오른쪽 세로획 (0.82→0.84)
            [{ type: 'line', start: [0.61, 0.45], end: [0.84, 0.45] }], // 7획: 두 번째 ㅂ 가운데 가로획
            [{ type: 'line', start: [0.61, 0.7], end: [0.84, 0.7] }]    // 8획: 두 번째 ㅂ 아래 가로획
        ],
        'ㅆ': [
            [{ type: 'line', start: [0.4, 0.3], end: [0.15, 0.7] }],    // 1획: 첫 번째 ㅅ 오른쪽 대각선
            [{ type: 'line', start: [0.33, 0.4], end: [0.55, 0.66] }],  // 2획: 첫 번째 ㅅ 왼쪽 대각선
            [{ type: 'line', start: [0.8, 0.3], end: [0.55, 0.7] }],    // 3획: 두 번째 ㅅ 오른쪽 대각선
            [{ type: 'line', start: [0.73, 0.4], end: [0.95, 0.66] }]   // 4획: 두 번째 ㅅ 왼쪽 대각선
        ],
        'ㅉ': [
            [{ type: 'line', start: [0.2, 0.3], end: [0.4, 0.3] }, { type: 'line', start: [0.4, 0.3], end: [0.25, 0.7] }],   // 1획: 첫 번째 ㅈ 가로+대각선
            [{ type: 'line', start: [0.32, 0.5], end: [0.45, 0.65] }],  // 2획: 첫 번째 ㅈ 오른쪽 대각선
            [{ type: 'line', start: [0.5, 0.3], end: [0.7, 0.3] }, { type: 'line', start: [0.7, 0.3], end: [0.55, 0.7] }],   // 3획: 두 번째 ㅈ 가로+대각선 (0.6→0.5, 0.8→0.7)
            [{ type: 'line', start: [0.62, 0.5], end: [0.75, 0.65] }]   // 4획: 두 번째 ㅈ 오른쪽 대각선 (0.72→0.62, 0.85→0.75)
        ],
        // 이중모음 (기본 모음 조합)
        'ㅐ': [
            [{ type: 'line', start: [0.4, 0.2], end: [0.4, 0.8] }],     // 1획: ㅏ 세로줄
            [{ type: 'line', start: [0.4, 0.5], end: [0.6, 0.5] }],     // 2획: ㅏ 가로줄
            [{ type: 'line', start: [0.6, 0.2], end: [0.6, 0.8] }]      // 3획: ㅣ 세로줄
        ],
        'ㅒ': [
            [{ type: 'line', start: [0.4, 0.2], end: [0.4, 0.8] }],     // 1획: ㅑ 세로줄
            [{ type: 'line', start: [0.4, 0.42], end: [0.6, 0.42] }],   // 2획: ㅑ 위 가로줄 (길이 0.2)
            [{ type: 'line', start: [0.4, 0.58], end: [0.6, 0.58] }],   // 3획: ㅑ 아래 가로줄 (길이 0.2)
            [{ type: 'line', start: [0.6, 0.2], end: [0.6, 0.8] }]      // 4획: ㅣ 세로줄 (0.7→0.6)
        ],
        'ㅔ': [
            [{ type: 'line', start: [0.4, 0.5], end: [0.6, 0.5] }],     // 1획: ㅓ 가로줄
            [{ type: 'line', start: [0.6, 0.2], end: [0.6, 0.8] }],     // 2획: ㅓ 세로줄
            [{ type: 'line', start: [0.7, 0.2], end: [0.7, 0.8] }]      // 3획: ㅣ 세로줄
        ],
        'ㅖ': [
            [{ type: 'line', start: [0.3, 0.42], end: [0.5, 0.42] }],   // 1획: ㅕ 위 가로줄
            [{ type: 'line', start: [0.3, 0.58], end: [0.5, 0.58] }],   // 2획: ㅕ 아래 가로줄
            [{ type: 'line', start: [0.5, 0.2], end: [0.5, 0.8] }],     // 3획: ㅕ 세로줄
            [{ type: 'line', start: [0.6, 0.2], end: [0.6, 0.8] }]      // 4획: ㅣ 세로줄 (0.7→0.6)
        ],
        'ㅘ': [
            [{ type: 'line', start: [0.4, 0.3], end: [0.4, 0.45] }],    // 1획: ㅗ 세로줄
            [{ type: 'line', start: [0.15, 0.45], end: [0.65, 0.45] }], // 2획: ㅗ 가로줄
            [{ type: 'line', start: [0.75, 0.15], end: [0.75, 0.75] }], // 3획: ㅏ 세로줄
            [{ type: 'line', start: [0.75, 0.4], end: [0.95, 0.4] }]    // 4획: ㅏ 가로줄 (위로 이동)
        ],
        'ㅙ': [
            [{ type: 'line', start: [0.35, 0.3], end: [0.35, 0.45] }],  // 1획: ㅗ 세로줄
            [{ type: 'line', start: [0.1, 0.45], end: [0.6, 0.45] }],   // 2획: ㅗ 가로줄
            [{ type: 'line', start: [0.7, 0.15], end: [0.7, 0.75] }],   // 3획: ㅏ 세로줄
            [{ type: 'line', start: [0.7, 0.4], end: [0.9, 0.4] }],     // 4획: ㅏ 가로줄 (위로 이동)
            [{ type: 'line', start: [0.95, 0.15], end: [0.95, 0.75] }]  // 5획: ㅣ 세로줄
        ],
        
        'ㅚ': [
            [{ type: 'line', start: [0.4, 0.3], end: [0.4, 0.45] }],    // 1획: ㅗ 세로줄
            [{ type: 'line', start: [0.15, 0.45], end: [0.65, 0.45] }], // 2획: ㅗ 가로줄 (y=0.45)
            [{ type: 'line', start: [0.7, 0.15], end: [0.7, 0.75] }]    // 3획: ㅣ 세로줄 (0.1→0.15, 0.75→0.75)
        ],
        'ㅝ': [
            [{ type: 'line', start: [0.15, 0.55], end: [0.65, 0.55] }], // 1획: ㅜ 가로줄
            [{ type: 'line', start: [0.4, 0.55], end: [0.4, 0.75] }],    // 2획: ㅜ 세로줄 (길이 늘림)
            [{ type: 'line', start: [0.55, 0.65], end: [0.75, 0.65] }],   // 3획: ㅓ 가로줄 (원래 길이로 복원)
            [{ type: 'line', start: [0.75, 0.3], end: [0.75, 0.8] }]    // 4획: ㅓ 세로줄 (0.45→0.3으로 위로 연장)
        ],
        'ㅞ': [
            [{ type: 'line', start: [0.05, 0.5], end: [0.5, 0.5] }],    // 1획: ㅜ 가로줄
            [{ type: 'line', start: [0.275, 0.5], end: [0.275, 0.7] }], // 2획: ㅜ 세로줄 (길이 늘림)
            [{ type: 'line', start: [0.5, 0.6], end: [0.7, 0.6] }],   // 3획: ㅓ 가로줄 (0.55→0.6로 더 아래로 이동)
            [{ type: 'line', start: [0.7, 0.25], end: [0.7, 0.75] }],     // 4획: ㅓ 세로줄 (0.3→0.25로 위로 연장)
            [{ type: 'line', start: [0.85, 0.25], end: [0.85, 0.75] }]    // 5획: ㅣ 세로줄 (0.3→0.25로 위로 연장)
        ],
        'ㅟ': [
            [{ type: 'line', start: [0.15, 0.55], end: [0.65, 0.55] }], // 1획: ㅜ 가로줄
            [{ type: 'line', start: [0.4, 0.55], end: [0.4, 0.7] }],    // 2획: ㅜ 세로줄 (0.3→0.4, 가운데로)
            [{ type: 'line', start: [0.7, 0.2], end: [0.7, 0.8] }]      // 3획: ㅣ 세로줄
        ],
        'ㅢ': [
            [{ type: 'line', start: [0.2, 0.5], end: [0.6, 0.5] }],     // 1획: ㅡ 가로줄
            [{ type: 'line', start: [0.7, 0.2], end: [0.7, 0.8] }]      // 2획: ㅣ 세로줄
        ]
        };
        
        // 자음·모음 학습 관련 함수들
                function initializeJamoLearning() {
                    createConsonantCards();
                    createVowelCards();
                    createFinalCards();
                    showJamoTab('consonants'); // 기본적으로 자음 탭 표시
                }
        
                function showJamoTab(tabName) {
                    // 모든 탭 버튼 비활성화
                    document.querySelectorAll('.jamo-tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // 모든 탭 컨텐츠 숨기기
                    document.querySelectorAll('.jamo-tab-content').forEach(content => {
                        content.classList.add('hidden');
                    });
                    
                    // 선택된 탭 활성화
                    if (tabName === 'consonants') {
                        document.querySelector('.jamo-tab-button:nth-child(1)').classList.add('active');
                        document.getElementById('consonantsTab').classList.remove('hidden');
                    } else if (tabName === 'vowels') {
                        document.querySelector('.jamo-tab-button:nth-child(2)').classList.add('active');
                        document.getElementById('vowelsTab').classList.remove('hidden');
                    } else if (tabName === 'finals') {
                        document.querySelector('.jamo-tab-button:nth-child(3)').classList.add('active');
                        document.getElementById('finalsTab').classList.remove('hidden');
                    }
                }
        
                function createConsonantCards() {
                    // 기본 자음 (ㄱ-ㅎ) + 쌍자음 순서로 배열
                    const consonants = [
                        // 기본 자음
                        'ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ',
                        // 쌍자음
                        'ㄲ', 'ㄸ', 'ㅃ', 'ㅆ', 'ㅉ'
                    ];
                    const grid = document.getElementById('consonantsGrid');
                    grid.innerHTML = '';
        
                    consonants.forEach(consonant => {
                        const sound = INITIAL_PRONUNCIATION[consonant] || consonant;
                        const card = createJamoCard(consonant, sound, 'consonant', '자음');
                        grid.appendChild(card);
                    });
                }
        
                function createVowelCards() {
                    // 기본 모음 (ㅏ-ㅣ) + 이중모음 순서로 배열
                    const vowels = [
                        // 기본 모음
                        'ㅏ', 'ㅑ', 'ㅓ', 'ㅕ', 'ㅗ', 'ㅛ', 'ㅜ', 'ㅠ', 'ㅡ', 'ㅣ',
                        // 이중모음
                        'ㅐ', 'ㅒ', 'ㅔ', 'ㅖ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅢ'
                    ];
                    const grid = document.getElementById('vowelsGrid');
                    grid.innerHTML = '';
        
                    vowels.forEach(vowel => {
                        const sound = VOWEL_PRONUNCIATION[vowel] || vowel;
                        const card = createJamoCard(vowel, sound, 'vowel', '모음');
                        grid.appendChild(card);
                    });
                }
        
                function createFinalCards() {
                    // 기본 받침 7개 (ㄱ,ㄴ,ㄹ,ㅁ,ㅂ,ㅅ,ㅇ)
                    const finals = ['ㄱ', 'ㄴ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ'];
                    const grid = document.getElementById('finalsGrid');
                    grid.innerHTML = '';
        
                    finals.forEach(final => {
                        const sound = FINAL_PRONUNCIATION[final] || final;
                        const card = createJamoCard(final, sound, 'final', '받침');
                        grid.appendChild(card);
                    });
                }
        
              function createJamoCard(jamo, sound, type, typeLabel) {
            const card = document.createElement('div');
            card.className = `jamo-card ${type}-card`;
            
            card.innerHTML = `
                <div class="jamo-card-jamo">${jamo}</div>
                <div class="jamo-card-type ${type}-type">${typeLabel}</div>
            `;
        
                card.addEventListener('click', () => {
    // 획순 모달창 열기 (통계는 모달창에서 실제 그리기 후 닫을 때 기록)
    openStrokeModal(jamo, sound, type);
});
              
                    return card;
                }
        
                // 획순 모달창 관련 변수들
                let currentJamo = '';
                let currentSound = '';
                let currentType = '';
                let canvas = null;
                let ctx = null;
                let isDrawing = false;
                let isPracticeMode = false;
        let currentStrokeIndex = 0;
                let strokeAnimationInterval = null;
                let isShowingStrokes = false;
let hasUserDrawn = false;
        
          function openStrokeModal(jamo, sound, type) {
    console.log('모달 열기:', jamo, sound, type);
    currentJamo = jamo;
    currentSound = sound;
    currentType = type;
    hasUserDrawn = false;

    document.getElementById('modalJamoTitle').textContent = jamo;
    document.getElementById('strokeOrderModal').classList.remove('hidden');

    // 모달이 열리자마자 즉시 지우기 버튼 숨기기
    const clearButton = document.querySelector('.stroke-btn');
    if (clearButton) {
        clearButton.style.display = 'none';
    }

    // 소리 재생 버튼에 이벤트 리스너 추가
    const soundReplayBtn = document.getElementById('soundReplayBtn');
    soundReplayBtn.removeEventListener('click', handleSoundReplay);
    soundReplayBtn.addEventListener('click', handleSoundReplay);

    // type이 'consonant'이고 jamo가 'ㅇ'일 때만 스피커 버튼 숨기기 (자음 ㅇ)
    if (jamo === 'ㅇ' && type === 'consonant') {
        soundReplayBtn.style.display = 'none';
    } else {
        soundReplayBtn.style.display = 'block';
        // 받침 ㅇ이나 다른 소리가 있을 때 자동 소리 재생
        setTimeout(() => {
            playModalSound(sound);
        }, 300);
    }

    // 캔버스 초기화
    canvas = document.getElementById('strokeCanvas');
    ctx = canvas.getContext('2d');
    
    // 아이패드용 캔버스 설정 추가
    if (canvas) {
        canvas.style.touchAction = 'none';
        canvas.style.userSelect = 'none';
        canvas.style.webkitUserSelect = 'none';
        canvas.style.webkitTouchCallout = 'none';
    }
    
    setupCanvas();
    
    // 아이패드 호환성을 위한 캔버스 완전 초기화 추가
    setTimeout(() => {
        if (ctx) {
            // 캔버스 완전 초기화
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
            ctx.setLineDash([]);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }
        
        clearCanvas();
        isPracticeMode = false;  // 획순 재생 모드로 시작
        drawGuideCharacter();    // 획순 재생 시작
    }, 300);
    console.log('모달 설정 완료, currentSound:', currentSound);
}
        
                // 소리 재생 이벤트 핸들러
                function handleSoundReplay(event) {
                    event.preventDefault();
                    console.log('소리 재생 버튼 클릭됨, currentSound:', currentSound);
                    try {
                        if (currentSound) {
                            playModalSound(currentSound);
                        } else {
                            console.error('currentSound가 설정되지 않음');
                        }
                    } catch (error) {
                        console.error('소리 재생 중 오류:', error);
                    }
                }
        
                // 모달창용 소리 재생 함수
           function playModalSound(sound) {
    playUnifiedSound(sound);
}
        
           function closeStrokeModal() {
    // 사용자가 실제로 그렸을 때만 학습 통계 업데이트
    if (hasUserDrawn && currentUser && currentJamo && currentType) {
        updateLearningStats(currentJamo, currentType);
    }
    
    // 획순 애니메이션 중단
    stopStrokeAnimation();
    
    // 지우기 버튼 다시 표시 (다음 모달 열기를 위해)
    const clearButton = document.querySelector('.stroke-btn');
    if (clearButton) {
        clearButton.style.display = 'block';
    }
    
    document.getElementById('strokeOrderModal').classList.add('hidden');
    if (canvas) {
        clearCanvas();
    }
    
    // 변수 초기화
    hasUserDrawn = false;
}
        
           function setupCanvas() {
    if (!canvas || !ctx) return;

    // 캔버스 설정
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 8;
    
    // 기존 이벤트 리스너 제거
    canvas.removeEventListener('touchstart', startDrawing);
    canvas.removeEventListener('touchmove', draw);
    canvas.removeEventListener('touchend', stopDrawing);
    canvas.removeEventListener('mousedown', startDrawing);
    canvas.removeEventListener('mousemove', draw);
    canvas.removeEventListener('mouseup', stopDrawing);
    canvas.removeEventListener('mouseout', stopDrawing);
    
    // 터치 이벤트 (모바일/아이패드) - passive: false로 preventDefault 허용
    canvas.addEventListener('touchstart', startDrawing, { passive: false });
    canvas.addEventListener('touchmove', draw, { passive: false });
    canvas.addEventListener('touchend', stopDrawing, { passive: false });
    canvas.addEventListener('touchcancel', stopDrawing, { passive: false });
    
    // 마우스 이벤트 (데스크탑)
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    // 아이패드용 추가 설정
    canvas.style.touchAction = 'none';
    canvas.style.userSelect = 'none';
    canvas.style.webkitUserSelect = 'none';
}
        
      function clearCanvas() {
    if (!ctx) return;
    
    // 획순 애니메이션 중단
    stopStrokeAnimation();
    
    // 아이패드에서 캔버스 완전 초기화
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 캔버스 상태 완전 리셋
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = '#000000';
    ctx.fillStyle = '#000000';
    ctx.lineWidth = 1;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.setLineDash([]);
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // 연습모드일 때만 가이드라인 표시
    if (isPracticeMode) {
        drawGuideLines();
    } else {
        drawGuideLines();
    }
}
        
               function drawGuideLines() {
    if (!ctx) return;
    
    // 아이패드에서 기존 그리기 상태 완전 초기화
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // 변형 행렬 초기화
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    
    // 가이드라인 전용 스타일 설정
    ctx.strokeStyle = '#e0e0e0';
    ctx.fillStyle = 'transparent';
    ctx.lineWidth = 1;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.setLineDash([5, 5]);
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // 중앙 십자선 그리기
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.moveTo(0, canvas.height / 2);
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();
    
    // 상태 완전 복원
    ctx.setLineDash([]);
    ctx.restore();
}
        
               
     function practiceMode() {
    // 아이패드에서 완전한 모드 전환을 위한 강력한 초기화
    stopStrokeAnimation();
    isShowingStrokes = false;
    strokeAnimationInterval = null;
    
    // 캔버스 완전 초기화
    if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore(); // 이전 저장된 상태 복원
    }
    
    isPracticeMode = true;
    
    // 연습모드에서는 가이드라인만 표시
    drawGuideLines();
}
        
         // ← 여기에 아래 함수를 추가
                function createStrokeMask(strokeIndex) {
                    if (!ctx) return null;
                    
                    const strokes = STROKE_ORDER[currentJamo];
                    if (!strokes) return null;
                    
                    // 임시 캔버스 생성
                    const maskCanvas = document.createElement('canvas');
                    const maskCtx = maskCanvas.getContext('2d');
                    maskCanvas.width = canvas.width;
                    maskCanvas.height = canvas.height;
                    
                    // 현재 획까지의 영역을 마스크로 생성
                    maskCtx.fillStyle = 'white';
                    const centerX = maskCanvas.width / 2;
                    const centerY = maskCanvas.height / 2;
                    
        
        // 개별 조정값 가져오기
        const adjustment = STROKE_ADJUSTMENTS[currentJamo] || DEFAULT_ADJUSTMENT;
        
                    // 글자 크기 계산 + 개별 조정
        maskCtx.font = '200px "Malgun Gothic", Arial, sans-serif';
        const metrics = maskCtx.measureText(currentJamo);
        const actualFontHeight = 200 * 1.0;
        const scaleX = actualFontHeight * adjustment.scaleX;
        const scaleY = actualFontHeight * adjustment.scaleY;
        const adjustedCenterX = centerX + adjustment.offsetX;
        const adjustedCenterY = centerY + adjustment.offsetY;
                    
                    for (let i = 0; i <= strokeIndex; i++) {
                        const strokeGroup = strokes[i];
                        maskCtx.lineWidth = 12;
                        maskCtx.lineCap = 'round';
                        maskCtx.strokeStyle = 'white';
                        
                        for (let j = 0; j < strokeGroup.length; j++) {
                            const stroke = strokeGroup[j];
                            maskCtx.beginPath();
                            
                           if (stroke.type === 'line') {
            const startX = adjustedCenterX + (stroke.start[0] - 0.5) * scaleX;
            const startY = adjustedCenterY + (stroke.start[1] - 0.5) * scaleY;
            const endX = adjustedCenterX + (stroke.end[0] - 0.5) * scaleX;
            const endY = adjustedCenterY + (stroke.end[1] - 0.5) * scaleY;
                                
                                maskCtx.moveTo(startX, startY);
                                maskCtx.lineTo(endX, endY);
                          } else if (stroke.type === 'circle') {
            const circleX = adjustedCenterX + (stroke.center[0] - 0.5) * scaleX;
            const circleY = adjustedCenterY + (stroke.center[1] - 0.5) * scaleY;
                                const radius = stroke.radius * scaleX;  
                                
                                maskCtx.arc(circleX, circleY, radius, 0, 2 * Math.PI);
                            }
                            maskCtx.stroke();
                        }
                    }
                    
                    return maskCanvas;
                }
        
  function drawGuideCharacter() {
    if (!ctx) return;
    
    // 연한 글씨 제거 - 바로 획순 애니메이션 시작
    showStrokeOrder();
}

function showStrokeOrder() {
    const strokes = STROKE_ORDER[currentJamo];
    if (!strokes) return;
    
    console.log('획순 애니메이션 시작, 총 획수:', strokes.length);
    
    currentStrokeIndex = 0;
    isShowingStrokes = true;
    isPracticeMode = false;  // 획순 재생 중에는 연습 모드 비활성화
    showStrokeInfo();
    
    strokeAnimationInterval = setInterval(() => {
        console.log('현재 획순:', currentStrokeIndex + 1, '/', strokes.length);
        
        if (currentStrokeIndex < strokes.length - 1) {
            currentStrokeIndex++;
            showStrokeInfo();
        } else {
            console.log('획순 애니메이션 완료, 연습 모드 시작');
            clearInterval(strokeAnimationInterval);
            strokeAnimationInterval = null;
            isShowingStrokes = false;
            
           setTimeout(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGuideLines();
                isPracticeMode = true;  // 이제 브러시 사용 가능
                
                // 연습 모드 시작 시 지우기 버튼 표시
                const clearButton = document.querySelector('.stroke-btn');
                if (clearButton) {
                    clearButton.style.display = 'block';
                }
                
                console.log('연습 모드 시작 - 브러시 사용 가능, 화살표 제거됨');
            }, 2000);
        }
    }, 3000);
}
        
  function showStrokeInfo() {
    const strokes = STROKE_ORDER[currentJamo];
    if (!strokes || currentStrokeIndex >= strokes.length) return;
    
    // 한 번만 캔버스 클리어
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGuideLines();
    
    // 모든 렌더링을 한 번에 처리
    ctx.save();
    
    // 현재 획까지 모든 획을 누적해서 그리기
    for (let i = 0; i <= currentStrokeIndex; i++) {
        ctx.beginPath();
        drawStrokePath(strokes[i], i);
        ctx.stroke();
    }
    
    ctx.restore();
    
    // 번호 표시
    showStrokeNumber(strokes[currentStrokeIndex][0], currentStrokeIndex + 1);
    
    // 방향 화살표 표시 - 획순 재생 중에만 표시
    if (isShowingStrokes) {
        drawDirectionArrows(strokes[currentStrokeIndex], currentStrokeIndex);
    }
}
        
        
             function drawCharacterWithStrokes() {
    const strokes = STROKE_ORDER[currentJamo];
    if (!strokes) return;
    
    // ㅇ은 특별 처리 (clipping 없이 직접 그리기)
    if (currentJamo === 'ㅇ' || currentJamo === 'ㅎ') {
        for (let i = 0; i <= currentStrokeIndex; i++) {
            ctx.save();
            ctx.fillStyle = '#000000';  // 검정색으로 통일
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            
            const adjustment = STROKE_ADJUSTMENTS[currentJamo] || DEFAULT_ADJUSTMENT;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const actualFontHeight = 200 * 1.0;
            const scaleX = actualFontHeight * adjustment.scaleX;
            const scaleY = actualFontHeight * adjustment.scaleY;
            const adjustedCenterX = centerX + adjustment.offsetX;
            const adjustedCenterY = centerY + adjustment.offsetY;
            
            const strokeGroup = strokes[i];
            for (let stroke of strokeGroup) {
                if (stroke.type === 'circle') {
                    const circleX = adjustedCenterX + (stroke.center[0] - 0.5) * scaleX;
                    const circleY = adjustedCenterY + (stroke.center[1] - 0.5) * scaleY;
                    const radius = stroke.radius * Math.min(scaleX, scaleY) + 5;
                    
                    ctx.beginPath();
                    // 여기서도 시계방향으로 변경
                    ctx.arc(circleX, circleY, radius, 0, 2 * Math.PI, false); // false 추가
                    ctx.stroke();
                } else if (stroke.type === 'line') {
                    const startX = adjustedCenterX + (stroke.start[0] - 0.5) * scaleX;
                    const startY = adjustedCenterY + (stroke.start[1] - 0.5) * scaleY;
                    const endX = adjustedCenterX + (stroke.end[0] - 0.5) * scaleX;
                    const endY = adjustedCenterY + (stroke.end[1] - 0.5) * scaleY;
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 12;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }
        return;
    }
            
            // 다른 글자들은 기존 방식
            for (let i = 0; i <= currentStrokeIndex; i++) {
                ctx.save();
                ctx.font = '200px "Malgun Gothic", Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (i === currentStrokeIndex) {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
                } else {
                    ctx.fillStyle = 'rgba(100, 150, 255, 0.5)';
                }
                
                // 클리핑 마스크 적용
                ctx.save();
                ctx.beginPath();
               drawStrokePath(strokes[i], i);  // 획순 인덱스도 함께 전달
                ctx.clip();
                ctx.fillText(currentJamo, canvas.width / 2, canvas.height / 2);
                ctx.restore();
                ctx.restore();
            }
        }
        
        function drawStrokePath(strokeGroup, strokeIndex) { 
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // 개별 조정값 가져오기
            const adjustment = STROKE_ADJUSTMENTS[currentJamo] || DEFAULT_ADJUSTMENT;
            
            // 실제 글자와 동일한 크기 계산 + 개별 조정
            ctx.save();
            ctx.font = '200px "Malgun Gothic", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const metrics = ctx.measureText(currentJamo);
            
            const actualFontHeight = 200 * 1.0;
            const scaleX = actualFontHeight * adjustment.scaleX;
            const scaleY = actualFontHeight * adjustment.scaleY;
            const adjustedCenterX = centerX + adjustment.offsetX;
            const adjustedCenterY = centerY + adjustment.offsetY;
            ctx.restore();
            
            // 획순별 색상 배열
            const strokeColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD'];
            
            ctx.strokeStyle = strokeColors[strokeIndex] || '#000000';
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            
            for (let stroke of strokeGroup) {
                ctx.beginPath(); // 각 획마다 새로운 경로 시작
                
                if (stroke.type === 'line') {
                    const startX = adjustedCenterX + (stroke.start[0] - 0.5) * scaleX;
                    const startY = adjustedCenterY + (stroke.start[1] - 0.5) * scaleY;
                    const endX = adjustedCenterX + (stroke.end[0] - 0.5) * scaleX;
                    const endY = adjustedCenterY + (stroke.end[1] - 0.5) * scaleY;
                    
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                } else if (stroke.type === 'circle') {
                    const circleX = adjustedCenterX + (stroke.center[0] - 0.5) * scaleX;
                    const circleY = adjustedCenterY + (stroke.center[1] - 0.5) * scaleY;
                    const radius = stroke.radius * Math.min(scaleX, scaleY) + 5;
                    
                ctx.arc(circleX, circleY, radius, 0, 2 * Math.PI, false); // false 추가
}
                
                ctx.stroke(); // 각 획마다 개별적으로 stroke 호출
            }
        }
        
        function drawStroke(stroke) {
                    if (!ctx) return;
                    
                    // 글씨체와 동일한 설정으로 스케일 계산
                    ctx.save();
                    ctx.font = '200px "Malgun Gothic", Arial, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // 실제 글자 크기를 측정
                    const metrics = ctx.measureText(currentJamo);
                    const actualWidth = metrics.width;
                    const actualHeight = 200; // 폰트 크기
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // 글자 크기에 맞춘 스케일
                    const scaleX = actualWidth;
                    const scaleY = actualHeight;
                    
                    ctx.restore();
                    
                    // 선 굵기를 글자 굵기와 비슷하게 설정
                    const originalLineWidth = ctx.lineWidth;
                    ctx.lineWidth = Math.max(originalLineWidth, 12); // 글자와 비슷한 굵기
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    
                    if (stroke.type === 'line') {
                        const startX = centerX + (stroke.start[0] - 0.5) * scaleX;
                        const startY = centerY + (stroke.start[1] - 0.5) * scaleY;
                        const endX = centerX + (stroke.end[0] - 0.5) * scaleX;
                        const endY = centerY + (stroke.end[1] - 0.5) * scaleY;
                        
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                  } else if (stroke.type === 'circle') {
            const circleX = adjustedCenterX + (stroke.center[0] - 0.5) * scaleX;
            const circleY = adjustedCenterY + (stroke.center[1] - 0.5) * scaleY;
            const radius = stroke.radius * Math.min(scaleX, scaleY) + 5;
            
            // 획순별 색상 배열
            const strokeColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD'];
            
           ctx.strokeStyle = strokeColors[strokeIndex] || '#000000';
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            
            ctx.arc(circleX, circleY, radius, 0, 2 * Math.PI);
        }
                    
        
                }
        
      function showStrokeNumber(stroke, number) {
    if (!ctx) return;
    
    // 글자 크기에 맞춘 스케일 계산
    ctx.save();
    ctx.font = '200px "Malgun Gothic", Arial, sans-serif';
    const metrics = ctx.measureText(currentJamo);
    const actualWidth = metrics.width;
    const actualHeight = 200;
    ctx.restore();
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const scaleX = actualWidth;
    const scaleY = actualHeight;
    
    let numberX, numberY;
    
    if (stroke.type === 'circle') {
        const adjustment = STROKE_ADJUSTMENTS[currentJamo] || DEFAULT_ADJUSTMENT;
        const adjustedCenterX = centerX + adjustment.offsetX;
        const adjustedCenterY = centerY + adjustment.offsetY;
        
        // 원의 왼쪽에 번호 표시 (시작점 위치)
        const circleX = adjustedCenterX + (stroke.center[0] - 0.5) * actualHeight * adjustment.scaleX;
        const circleY = adjustedCenterY + (stroke.center[1] - 0.5) * actualHeight * adjustment.scaleY;
        const radius = stroke.radius * Math.min(actualHeight * adjustment.scaleX, actualHeight * adjustment.scaleY) + 5;
        
        // 왼쪽 위 방향에 번호 위치 (시계방향 시작점)
        numberX = circleX + radius * Math.cos(-2*Math.PI/3) - 25; // 왼쪽으로 더 이동
        numberY = circleY + radius * Math.sin(-2*Math.PI/3) - 15; // 위쪽으로 약간 이동
    } else {
        numberX = centerX + (stroke.start[0] - 0.5) * scaleX - 20;
        numberY = centerY + (stroke.start[1] - 0.5) * scaleY - 15;
    }
    
    ctx.save();
    ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
    ctx.beginPath();
    ctx.arc(numberX, numberY, 18, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(number.toString(), numberX, numberY);
    ctx.restore();
}
        
        function stopStrokeAnimation() {
                    if (strokeAnimationInterval) {
                        clearInterval(strokeAnimationInterval);
                        strokeAnimationInterval = null;
                    }
                    isShowingStrokes = false;
                    currentStrokeIndex = 0;
                }
        // 방향 화살표를 그리는 함수 (정확한 획순 위치)
        function drawDirectionArrows(strokeGroup, strokeIndex) {
            if (!ctx) return;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // 개별 조정값 가져오기
            const adjustment = STROKE_ADJUSTMENTS[currentJamo] || DEFAULT_ADJUSTMENT;
            
            // 실제 글자와 동일한 크기 계산 + 개별 조정
            ctx.save();
            ctx.font = '200px "Malgun Gothic", Arial, sans-serif';
            const metrics = ctx.measureText(currentJamo);
            const actualFontHeight = 200 * 1.0;
            const scaleX = actualFontHeight * adjustment.scaleX;
            const scaleY = actualFontHeight * adjustment.scaleY;
            const adjustedCenterX = centerX + adjustment.offsetX;
            const adjustedCenterY = centerY + adjustment.offsetY;
            ctx.restore();
            
            // 화살표 색상 설정
            ctx.strokeStyle = '#FF4757';
            ctx.fillStyle = '#FF4757';
            ctx.lineWidth = 3;
        
            // 꺾이는 획인지 확인 (strokeGroup의 length가 2 이상이고 모두 line인 경우)
            if (strokeGroup.length >= 2 && strokeGroup.every(s => s.type === 'line')) {
                // 꺾이는 획의 경우: 첫 번째 선분에만 화살표 표시
                const firstStroke = strokeGroup[0];
                const startX = adjustedCenterX + (firstStroke.start[0] - 0.5) * scaleX;
                const startY = adjustedCenterY + (firstStroke.start[1] - 0.5) * scaleY;
                const endX = adjustedCenterX + (firstStroke.end[0] - 0.5) * scaleX;
                const endY = adjustedCenterY + (firstStroke.end[1] - 0.5) * scaleY;
                
                drawArrowOutside(startX, startY, endX, endY, strokeIndex);
                
            } else {
                // 각 stroke별로 화살표 그리기
                for (let i = 0; i < strokeGroup.length; i++) {
                    const stroke = strokeGroup[i];
                    
                    if (stroke.type === 'line') {
                        const startX = adjustedCenterX + (stroke.start[0] - 0.5) * scaleX;
                        const startY = adjustedCenterY + (stroke.start[1] - 0.5) * scaleY;
                        const endX = adjustedCenterX + (stroke.end[0] - 0.5) * scaleX;
                        const endY = adjustedCenterY + (stroke.end[1] - 0.5) * scaleY;
                        
                        drawArrowOutside(startX, startY, endX, endY, strokeIndex);
                        
                    } else if (stroke.type === 'circle') {
                        // 원형 글자는 중앙에 위치하도록 offset 무시
                        const circleX = centerX + (stroke.center[0] - 0.5) * scaleX;
                        const circleY = centerY + (stroke.center[1] - 0.5) * scaleY;
                        const radius = stroke.radius * Math.min(scaleX, scaleY) + 5;
                        
                        // 원형 화살표는 한 번만 그리기
                        drawCircleArrowOutside(circleX, circleY, radius);
                    }
                }
            }
        }
        
        // 직선 화살표 그리기 함수 (모든 자모 최적화)
        function drawArrowOutside(startX, startY, endX, endY, strokeIndex) {
            const headLength = 20;
            const headAngle = Math.PI / 6;
            let offset = 40; // 기본 거리
            
            // 방향 계산
            const angle = Math.atan2(endY - startY, endX - startX);
            const lineLength = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
            
            let arrowX, arrowY;
            let positionRatio = 0.2; // 기본 위치
            
            // 자모별 개별 설정
            if (currentJamo === 'ㄱ') {
                offset = 25; // 획과 가깝게
                positionRatio = 0.15;
            } else if (currentJamo === 'ㄴ') {
                offset = 25; // 획과 가깝게
                positionRatio = 0.25; // 조금 내려와서
            } else if (currentJamo === 'ㄷ') {
                if (strokeIndex === 0) {
                    // 1획은 획과 가깝게
                    offset = 25;
                    positionRatio = 0.15;
                } else {
                    // 2획은 더 아래로 내려서
                    offset = 25;
                    positionRatio = 0.5; // 0.35에서 0.5로 더 아래로
                }
            } else if (currentJamo === 'ㄹ') {
                if (strokeIndex === 1) {
                    // 2획만 바로 위에 표시
                    offset = 20; // 25→20으로 더 가깝게
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    arrowX = midX;
                    arrowY = midY - offset;
                } else if (strokeIndex === 2) {
                    // 3획은 더 아래로, 오른쪽으로 이동
                    offset = 25;
                    positionRatio = 0.4; // 0.35→0.4로 조금 더 오른쪽으로
                } else {
                    // 1획
                    offset = 25;
                    positionRatio = 0.25;
                }
            } else if (currentJamo === 'ㅁ') {
                if (strokeIndex === 0) {
                    // 1획은 더 아래로
                    offset = 25;
                    positionRatio = 0.4; // 0.25→0.4로 더 아래로
                } else {
                    offset = 25;
                    positionRatio = 0.25;
                }
            } else if (currentJamo === 'ㅂ') {
                if (strokeIndex === 2) {
                    // 3획 (가운데 가로획)은 십자선 세로선 위치에 표시
                    offset = 25; // 30→25로 더 가깝게
                    const centerX = canvas.width / 2;
                    const midY = (startY + endY) / 2;
                    arrowX = centerX;
                    arrowY = midY - offset;
                } else if (strokeIndex === 3) {
                    // 4획 (아래 가로획)은 십자선 세로선 위치 아래에 표시
                    offset = 25; // 30→25로 더 가깝게
                    const centerX = canvas.width / 2;
                    const midY = (startY + endY) / 2;
                    arrowX = centerX;
                    arrowY = midY + offset; // 아래쪽으로 변경
                } else {
                    offset = 25; // 50→25로 더 가깝게
                    positionRatio = 0.4; // 0.5→0.4로 조금 올려서
                }
            } else if (currentJamo === 'ㅅ') {
                if (strokeIndex === 1) {
                    // 2획은 오른쪽 아래 대각선으로 더 내려서
                    offset = 30;
                    positionRatio = 0.5; // 0.3→0.5로 더 아래로
                } else {
                    offset = 30;
                    positionRatio = 0.3;
                }
            } else if (currentJamo === 'ㅇ') {
                // 원형이므로 여기서는 처리하지 않음
                return;
          } else if (currentJamo === 'ㅈ') {
            if (strokeIndex === 1) {
                // 2획은 오른쪽 아래로 더 멀리, 거리는 가깝게
                offset = 25;
                positionRatio = 0.6;
            } else {
                offset = 25;  // 50 → 25로 변경 (1획 화살표를 획과 가깝게)
                positionRatio = 0.2;
            }
        } else if (currentJamo === 'ㅊ') {
            if (strokeIndex === 0) {
                // 1획은 획의 정확한 가운데에 표시
                offset = 30;
                positionRatio = 0.5; // 획의 정확한 가운데 (50% 지점)
            } else if (strokeIndex === 1) {
                // 2획 (가로+대각선)은 가로 부분 가운데에 표시
                offset = 20;
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 15; // 왼쪽으로 15px 이동
                arrowY = midY + offset; // 가로획보다 살짝 아래
            } else if (strokeIndex === 2) {
                // 3획 (오른쪽 대각선)은 오른쪽 아래로 표시
                offset = 20;
                positionRatio = 0.5;
            } else {
                offset = 25;
                positionRatio = 0.2;
            }
        } else if (currentJamo === 'ㅋ') {
            if (strokeIndex === 1) {
                // 2획은 획 바로 위에 표시
                offset = 20;
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY - offset;
            } else {
                offset = 25;  // 55 → 25로 변경 (1획 화살표를 획과 가깝게)
                positionRatio = 0.15;
            }
        } else if (currentJamo === 'ㅌ') {
            if (strokeIndex === 1) {
                // 2획은 획 바로 위에 표시
                offset = 20;
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY - offset;
            } else if (strokeIndex === 2) {
                // 3획은 아래로 이동시켜서 획순번호를 가리지 않게 함
                offset = 30;
                positionRatio = 0.7;  // 0.15 → 0.7로 변경하여 아래로 이동
            } else {
                offset = 25;  // 55 → 25로 변경 (1획 화살표를 획과 가깝게)
                positionRatio = 0.15;
            }
            } else if (currentJamo === 'ㅍ') {
            if (strokeIndex === 0) {
                // 1획 (위 가로획)은 획과 가깝게
                offset = 25;
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획 (왼쪽 세로획)은 획과 가깝게
                offset = 25;
                positionRatio = 0.6;
            } else if (strokeIndex === 2) {
                // 3획 (오른쪽 세로획)은 획과 가깝게, 아래쪽으로 내려서 획순번호 안 가리게
                offset = 25;
                positionRatio = 0.7; // 아래쪽으로 이동
            } else if (strokeIndex === 3) {
                // 4획 (아래 가로획)은 획과 가깝게, 아래쪽으로 내려서 획순번호 안 가리게
                offset = 25;
                positionRatio = 0.7; // 아래쪽으로 이동
            } else {
                offset = 25;
                positionRatio = 0.2;
            }
        } else if (currentJamo === 'ㅎ') {
                if (strokeIndex === 0) {
                    // 1획 (짧은 가로줄)은 해당 획 바로 아래에 표시
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    arrowX = midX;
                    arrowY = midY - 25; // 아래쪽으로 25px 이동
                } else if (strokeIndex === 1) {
                    // 2획 (긴 가로줄)은 해당 획 바로 아래에 표시
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    arrowX = midX;
                    arrowY = midY + 25; // 아래쪽으로 25px 이동
                } else {
                    // 3획 (원)은 기존 설정 유지
                    offset = 60;
                    positionRatio = 0.2;
                }
            }
        
            // 쌍자음
          // 쌍자음
        else if (currentJamo === 'ㄲ') {
            offset = 25;  // 55 → 25로 변경 (획과 가깝게)
            positionRatio = 0.15;
        } else if (currentJamo === 'ㄸ') {
            if (strokeIndex === 0) {
                // 1획 (첫 번째 ㄷ 위쪽 가로획)은 획과 가깝게
                offset = 25;
                positionRatio = 0.15;
            } else if (strokeIndex === 1) {
                // 2획 (첫 번째 ㄷ 세로+가로)은 획과 가깝게, 더 아래로 내려서 획순번호 안 가리게
                offset = 25;
                positionRatio = 0.6; // 더 아래로 이동
            } else if (strokeIndex === 2) {
                // 3획 (두 번째 ㄷ 위쪽 가로획)은 획과 가깝게
                offset = 25;
                positionRatio = 0.15;
            } else if (strokeIndex === 3) {
               arrowX = startX - 20;  
                arrowY = startY + 40;  
         
            } else {
                offset = 25;
                positionRatio = 0.15;
            }
        } else if (currentJamo === 'ㅃ') {
            if (strokeIndex === 0) {
                // 1획 (첫 번째 ㅂ 왼쪽 세로획)은 획과 가깝게
                offset = 25;
                positionRatio = 0.3;
            } else if (strokeIndex === 1) {
                // 2획 (첫 번째 ㅂ 오른쪽 세로획)은 획의 오른쪽에 가깝게
                offset = 25;
                const quarterX = startX + (endX - startX) * 0.3;
                const quarterY = startY + (endY - startY) * 0.3;
                arrowX = quarterX + 30; // 오른쪽으로 30px 이동
                arrowY = quarterY;
            } else if (strokeIndex === 2) {
                // 3획 (첫 번째 ㅂ 가운데 가로획)은 획 바로 위에 (화살표 길이 줄임)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY - 20; // 위쪽으로 20px (짧은 화살표)
            } else if (strokeIndex === 3) {
                // 4획 (첫 번째 ㅂ 아래 가로획)은 획 바로 아래에 (화살표 길이 줄임)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 20; // 아래쪽으로 20px (짧은 화살표)
           
              } else if (strokeIndex === 4) {
            // 5획 (두 번째 ㅂ 왼쪽 세로획)은 왼쪽으로 이동
            const quarterX = startX + (endX - startX) * 0.3;
            const quarterY = startY + (endY - startY) * 0.3;
            arrowX = quarterX - 15; // 왼쪽으로 30px 이동
            arrowY = quarterY;
        
            } else if (strokeIndex === 5) {
                // 6획 (두 번째 ㅂ 오른쪽 세로획)은 획의 오른쪽에 가깝게
                offset = 25;
                const quarterX = startX + (endX - startX) * 0.3;
                const quarterY = startY + (endY - startY) * 0.3;
                arrowX = quarterX + 30; // 오른쪽으로 30px 이동
                arrowY = quarterY;
            } else if (strokeIndex === 6) {
                // 7획 (두 번째 ㅂ 가운데 가로획)은 획 바로 위에 (화살표 길이 줄임)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY - 20; // 위쪽으로 20px (짧은 화살표)
            } else if (strokeIndex === 7) {
                // 8획 (두 번째 ㅂ 아래 가로획)은 획 바로 아래에 (화살표 길이 줄임)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 20; // 아래쪽으로 20px (짧은 화살표)
            } else {
                offset = 25;
                positionRatio = 0.15;
            }
        } else if (currentJamo === 'ㅆ') {
            if (strokeIndex === 0) {
                // 1획은 왼쪽 대각선 아래로
                arrowX = startX - 40;  // 왼쪽으로 40px 이동
                arrowY = startY + 40;  // 아래로 40px 이동
            } else if (strokeIndex === 1) {
                // 2획은 왼쪽 위 대각선 방향으로 이동
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 10;  // 왼쪽으로 10px 이동
                arrowY = midY + 20;  // 위로 20px 이동
            } else if (strokeIndex === 2) {
                // 3획은 1획과 동일하게 (왼쪽 대각선 아래로)
                arrowX = startX - 30;  // 왼쪽으로 40px 이동
                arrowY = startY + 20;  // 아래로 40px 이동
            } else if (strokeIndex === 3) {
                // 4획은 2획과 동일하게 (왼쪽 위 대각선 방향으로)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 10;  // 왼쪽으로 10px 이동
                arrowY = midY + 20;  // 위로 20px 이동
            } else {
                // 나머지 획들은 기존 설정 유지
                offset = 60;
                positionRatio = 0.25;
            }
        } else if (currentJamo === 'ㅉ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25;  // 55 → 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 오른쪽 위 대각선 방향으로 이동
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX + 20;  // 오른쪽으로 20px 이동
                arrowY = midY - 25;  // 위쪽으로 25px 이동
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게
                offset = 25;  // 55 → 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 3) {
                // 4획은 오른쪽 아래 대각선 방향으로 이동
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX + 20;  // 오른쪽으로 20px 이동
                arrowY = midY - 25;  // 아래쪽으로 25px 이동
            } else {
                // 나머지 획들은 기존 설정 유지
                offset = 55;
                positionRatio = 0.2;
            }
        }
            // 모음
            else if (currentJamo === 'ㅏ') {
              if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25; // 45에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 획 바로 아래에 오른쪽으로 조금 이동
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX + 15; // 오른쪽으로 15px 이동
                arrowY = midY + 20; // 아래쪽으로 20px 이동
            } else {
                offset = 45;
                positionRatio = 0.2;
            }
           } else if (currentJamo === 'ㅑ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25; // 50에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else {
                offset = 50;
                positionRatio = 0.2;
            }
         } else if (currentJamo === 'ㅓ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게, 오른쪽으로 이동
                const quarterX = startX + (endX - startX) * 0.2;
                const quarterY = startY + (endY - startY) * 0.2;
                
                const perpAngle = angle + Math.PI / 2;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const toCenterX = centerX - quarterX;
                const toCenterY = centerY - quarterY;
                
                let finalOffset = 25;
                if (toCenterX * Math.cos(perpAngle) + toCenterY * Math.sin(perpAngle) > 0) {
                    finalOffset = -25;
                }
                
                arrowX = quarterX + finalOffset * Math.cos(perpAngle) + 20; // 오른쪽으로 20px 이동
                arrowY = quarterY + finalOffset * Math.sin(perpAngle);
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게
                offset = 25;
                positionRatio = 0.2;
            } else {
                offset = 45;
                positionRatio = 0.2;
            }
          } else if (currentJamo === 'ㅕ') {
            if (strokeIndex === 0) {
                // 1획은 획 아래에, 2획과 동일한 위치로
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX; // 2획과 동일한 위치
                arrowY = midY + 25; // 아래쪽으로 25px 이동
            } else if (strokeIndex === 1) {
                // 2획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획 바로 아래에 오른쪽으로 이동 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX + 15; // 오른쪽으로 15px 이동
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else {
                offset = 50;
                positionRatio = 0.2;
            }
         } else if (currentJamo === 'ㅗ') {
            if (strokeIndex === 0) {
                // 1획 화살표를 획의 왼쪽에 배치
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 30; // 왼쪽으로 30px 이동
                arrowY = midY;
            } else if (strokeIndex === 1) {
                // 2획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else {
                offset = 50;
                positionRatio = 0.2;
            }
         } else if (currentJamo === 'ㅛ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게, 조금 아래로 내려서 획순 번호 안 가리게
                offset = 25; // 55에서 25로 변경
                positionRatio = 0.4; // 0.2에서 0.4로 변경하여 아래로 이동
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게, 왼쪽으로 이동하여 획순 번호 아래에 위치
                const quarterX = startX + (endX - startX) * 0.2;
                const quarterY = startY + (endY - startY) * 0.2;
                
                const perpAngle = angle + Math.PI / 2;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const toCenterX = centerX - quarterX;
                const toCenterY = centerY - quarterY;
                
                let finalOffset = 25;
                if (toCenterX * Math.cos(perpAngle) + toCenterY * Math.sin(perpAngle) > 0) {
                    finalOffset = -25;
                }
                
                arrowX = quarterX + finalOffset * Math.cos(perpAngle) - 40; // 왼쪽으로 20px 이동
                arrowY = quarterY + finalOffset * Math.sin(perpAngle);
            } else if (strokeIndex === 2) {
                // 3획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else {
                offset = 55;
                positionRatio = 0.2;
            }
        } else if (currentJamo === 'ㅜ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25; // 50에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게, 왼쪽으로 이동 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 15; // 왼쪽으로 15px 이동
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else {
                offset = 50;
                positionRatio = 0.2;
            }
         } else if (currentJamo === 'ㅠ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25; // 55에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게, 왼쪽으로 이동 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 15; // 왼쪽으로 15px 이동
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게, 획순 아래 위치하도록 왼쪽으로 이동 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 20; // 왼쪽으로 20px 이동
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else {
                offset = 55;
                positionRatio = 0.2;
            }
            } else if (currentJamo === 'ㅡ') {
                offset = 50;
                positionRatio = 0.5; // 가로줄은 중간에
            } else if (currentJamo === 'ㅣ') {
                offset = 50;
                positionRatio = 0.2;
            }
            // 이중모음
          else if (currentJamo === 'ㅐ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25; // 55에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게, 오른쪽으로 조금 이동 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX + 5; // 오른쪽으로 5px 이동
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게
                offset = 25; // 55에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 55;
                positionRatio = 0.2;
            }
           } else if (currentJamo === 'ㅒ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 3) {
                // 4획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 60;
                positionRatio = 0.2;
            }
          } else if (currentJamo === 'ㅔ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게, 오른쪽으로 이동
                const quarterX = startX + (endX - startX) * 0.2;
                const quarterY = startY + (endY - startY) * 0.2;
                
                const perpAngle = angle + Math.PI / 2;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const toCenterX = centerX - quarterX;
                const toCenterY = centerY - quarterY;
                
                let finalOffset = 25;
                if (toCenterX * Math.cos(perpAngle) + toCenterY * Math.sin(perpAngle) > 0) {
                    finalOffset = -25;
                }
                
                arrowX = quarterX + finalOffset * Math.cos(perpAngle) + 10; // 오른쪽으로 5px 이동
                arrowY = quarterY + finalOffset * Math.sin(perpAngle);
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게
                offset = 25; // 55에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게
                offset = 25; // 55에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 55;
                positionRatio = 0.2;
            }
          } else if (currentJamo === 'ㅖ') {
            if (strokeIndex === 0) {
                // 1획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 1) {
                // 2획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 3) {
                // 4획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 60;
                positionRatio = 0.2;
            }
          } else if (currentJamo === 'ㅘ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게, 조금 아래로 내려서 획순 번호 안 가리게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.4; // 0.2에서 0.4로 변경하여 아래로 이동
            } else if (strokeIndex === 1) {
                // 2획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 3) {
                // 4획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else {
                offset = 60;
                positionRatio = 0.2;
            }
           } else if (currentJamo === 'ㅙ') {
            if (strokeIndex === 0) {
                // 1획은 ㅘ와 동일하게 (획과 가깝게, 조금 아래로)
                offset = 25; // 65에서 25로 변경
                positionRatio = 0.4; // 아래로 이동
            } else if (strokeIndex === 1) {
                // 2획은 ㅘ와 동일하게 (획 바로 아래에, 짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 ㅘ와 동일하게 (획과 가깝게)
                offset = 25; // 65에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 3) {
                // 4획은 획 바로 아래에 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 4) {
                // 5획은 획과 가깝게
                offset = 25; // 65에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 65;
                positionRatio = 0.2;
            }
           } else if (currentJamo === 'ㅚ') {
            if (strokeIndex === 0) {
                // 1획은 ㅙ와 동일하게 (획과 가깝게, 조금 아래로)
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.4; // 아래로 이동
            } else if (strokeIndex === 1) {
                // 2획은 ㅙ와 동일하게 (획 바로 아래에, 짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 ㅙ와 동일하게 (획과 가깝게)
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 60;
                positionRatio = 0.2;
            }
          } else if (currentJamo === 'ㅝ') {
            if (strokeIndex === 0) {
                // 1획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게, 왼쪽으로 이동 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 15; // 왼쪽으로 15px 이동
                arrowY = midY + 10; // 아래쪽으로 10px 이동 (짧은 화살표)
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게 (짧은 화살표)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; // 아래쪽으로 15px 이동 (짧은 화살표)
            } else if (strokeIndex === 3) {
                // 4획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 60;
                positionRatio = 0.2;
            }
        } else if (currentJamo === 'ㅞ') {
            if (strokeIndex === 0) {
                // 1획은 획 아래에 직접 표시
                const quarterX = startX + (endX - startX) * 0.2;
                const quarterY = startY + (endY - startY) * 0.2;
                arrowX = quarterX;
                arrowY = quarterY + 20; // 아래쪽으로 20px 이동
            } else if (strokeIndex === 1) {
                // 2획은 ㅝ와 동일하게
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 15; 
                arrowY = midY + 15; 
            } else if (strokeIndex === 2) {
                // 3획은 ㅝ와 동일하게
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX;
                arrowY = midY + 15; 
            } else if (strokeIndex === 3) {
                // 4획은 ㅝ와 동일하게
                offset = 25; 
                positionRatio = 0.2;
            } else if (strokeIndex === 4) {
                // 5획은 획과 가깝게
                offset = 25; 
                positionRatio = 0.2;
            } else {
                offset = 65;
                positionRatio = 0.2;
            }
           } else if (currentJamo === 'ㅟ') {
            if (strokeIndex === 0) {
                // 1획은 ㅞ와 동일하게 (획 아래에 직접 표시, 획과 가깝게)
                const quarterX = startX + (endX - startX) * 0.2;
                const quarterY = startY + (endY - startY) * 0.2;
                arrowX = quarterX;
                arrowY = quarterY + 20; // 아래쪽으로 20px 이동
            } else if (strokeIndex === 1) {
                // 2획은 ㅞ와 동일하게 (왼쪽으로 10px 이동)
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                arrowX = midX - 15; // 왼쪽으로 10px 이동
                arrowY = midY + 15; 
            } else if (strokeIndex === 2) {
                // 3획은 획과 가깝게
                offset = 25; // 60에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 60;
                positionRatio = 0.2;
            }
            } else if (currentJamo === 'ㅢ') {
            if (strokeIndex === 0) {
                // 1획은 획 아래에 직접 표시, 획과 가깝게
                const quarterX = startX + (endX - startX) * 0.2;
                const quarterY = startY + (endY - startY) * 0.2;
                arrowX = quarterX;
                arrowY = quarterY + 20; // 아래쪽으로 20px 이동
            } else if (strokeIndex === 1) {
                // 2획은 획과 가깝게
                offset = 25; // 55에서 25로 변경
                positionRatio = 0.2;
            } else {
                offset = 55;
                positionRatio = 0.2;
            }
        }
            
        if (!(currentJamo === 'ㄹ' && strokeIndex === 1) && 
            !(currentJamo === 'ㅂ' && (strokeIndex === 2 || strokeIndex === 3)) &&
            !(currentJamo === 'ㅊ' && strokeIndex === 1) &&
            !(currentJamo === 'ㅋ' && strokeIndex === 1) &&
            !(currentJamo === 'ㅌ' && strokeIndex === 1) &&
            !(currentJamo === 'ㅎ' && (strokeIndex === 0 || strokeIndex === 1|| strokeIndex === 2)) &&
            !(currentJamo === 'ㄸ' && strokeIndex === 3) &&
            !(currentJamo === 'ㅃ' && (strokeIndex === 1 || strokeIndex === 2 || strokeIndex === 3 || strokeIndex === 4 || strokeIndex === 5 || strokeIndex === 6 || strokeIndex === 7)) &&
            !(currentJamo === 'ㅆ' && (strokeIndex === 0 || strokeIndex === 1 || strokeIndex === 2 || strokeIndex === 3)) &&
            !(currentJamo === 'ㅉ' && (strokeIndex === 1 || strokeIndex === 3)) &&
            !(currentJamo === 'ㅏ' && strokeIndex === 1) &&
            !(currentJamo === 'ㅑ' && (strokeIndex === 1 || strokeIndex === 2)) &&
            !(currentJamo === 'ㅓ' && strokeIndex === 0) &&
            !(currentJamo === 'ㅕ' && (strokeIndex === 0 || strokeIndex === 1 || strokeIndex === 2)) &&
            !(currentJamo === 'ㅗ' && (strokeIndex === 0 ||strokeIndex === 1)) &&
            !(currentJamo === 'ㅛ' && (strokeIndex === 1 || strokeIndex === 2)) &&
            !(currentJamo === 'ㅜ' && strokeIndex === 1) &&
            !(currentJamo === 'ㅠ' && (strokeIndex === 1 || strokeIndex === 2)) &&
            !(currentJamo === 'ㅐ' && strokeIndex === 1) &&
            !(currentJamo === 'ㅒ' && (strokeIndex === 1 || strokeIndex === 2)) &&
            !(currentJamo === 'ㅔ' && strokeIndex === 0) &&
            !(currentJamo === 'ㅖ' && (strokeIndex === 0 || strokeIndex === 1)) &&
            !(currentJamo === 'ㅘ' && (strokeIndex === 1 || strokeIndex === 3)) &&
            !(currentJamo === 'ㅙ' && (strokeIndex === 1 || strokeIndex === 3)) &&
            !(currentJamo === 'ㅚ' && strokeIndex === 1) &&
            !(currentJamo === 'ㅝ' && (strokeIndex === 1 || strokeIndex === 2)) &&
            !(currentJamo === 'ㅞ' && (strokeIndex === 0 || strokeIndex === 1 || strokeIndex === 2)) &&
            !(currentJamo === 'ㅟ' && (strokeIndex === 0 || strokeIndex === 1)) &&
            !(currentJamo === 'ㅢ' && strokeIndex === 0)) {
                const quarterX = startX + (endX - startX) * positionRatio;
                const quarterY = startY + (endY - startY) * positionRatio;
                
                const perpAngle = angle + Math.PI / 2;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const toCenterX = centerX - quarterX;
                const toCenterY = centerY - quarterY;
                
                let finalOffset = offset;
                if (toCenterX * Math.cos(perpAngle) + toCenterY * Math.sin(perpAngle) > 0) {
                    finalOffset = -offset;
                }
                
                arrowX = quarterX + finalOffset * Math.cos(perpAngle);
                arrowY = quarterY + finalOffset * Math.sin(perpAngle);
            }
            
            // 화살표 끝점 계산
            const arrowEndX = arrowX + headLength * Math.cos(angle);
            const arrowEndY = arrowY + headLength * Math.sin(angle);
            
            // 화살표 그리기
            ctx.save();
            ctx.strokeStyle = '#FF3742';
            ctx.fillStyle = '#FF3742';
            ctx.lineWidth = 3;
            
            // 화살표 몸통 그리기
            ctx.beginPath();
            ctx.moveTo(arrowX - headLength * 0.8 * Math.cos(angle), 
                       arrowY - headLength * 0.8 * Math.sin(angle));
            ctx.lineTo(arrowEndX, arrowEndY);
            ctx.stroke();
            
            // 화살표 머리 그리기
            ctx.beginPath();
            ctx.moveTo(arrowEndX, arrowEndY);
            ctx.lineTo(arrowEndX - headLength * 0.7 * Math.cos(angle - headAngle), 
                       arrowEndY - headLength * 0.7 * Math.sin(angle - headAngle));
            ctx.lineTo(arrowEndX - headLength * 0.7 * Math.cos(angle + headAngle), 
                       arrowEndY - headLength * 0.7 * Math.sin(angle + headAngle));
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
function drawCircleArrowOutside(centerX, centerY, radius) {
    ctx.save();
    ctx.strokeStyle = '#FF3742';
    ctx.fillStyle = '#FF3742';
    ctx.lineWidth = 3;
    
    if (currentJamo === 'ㅇ') {
        const arrowSize = 18;
        const offset = 25;
        
        // 왼쪽에서 시작해서 시계방향으로
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.arc(centerX, centerY, radius + offset, Math.PI, Math.PI/2, true); // 왼쪽에서 아래쪽으로
        ctx.stroke();
        
        // 화살표 머리를 아래쪽에 위치 (시계방향 끝점)
        const headX = centerX + (radius + offset) * Math.cos(Math.PI/2);
        const headY = centerY + (radius + offset) * Math.sin(Math.PI/2);
        
        // 시계방향 접선 방향
        const tangentAngle = Math.PI/2 - Math.PI/2;
        
        ctx.beginPath();
        ctx.moveTo(headX, headY);
        ctx.lineTo(headX - arrowSize * 0.6 * Math.cos(tangentAngle - Math.PI/6), 
                   headY - arrowSize * 0.6 * Math.sin(tangentAngle - Math.PI/6));
        ctx.lineTo(headX - arrowSize * 0.6 * Math.cos(tangentAngle + Math.PI/6), 
                   headY - arrowSize * 0.6 * Math.sin(tangentAngle + Math.PI/6));
        ctx.closePath();
        ctx.fill();
        
    } else if (currentJamo === 'ㅎ') {
        const arrowSize = 15;
        const offset = 20;
        const adjustedCenterX = centerX + 20;
        const adjustedCenterY = centerY - 20;
        
        // 동일하게 왼쪽에서 시작
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.arc(adjustedCenterX, adjustedCenterY, radius + offset, Math.PI, Math.PI/2, true);
        ctx.stroke();
        
        const headX = adjustedCenterX + (radius + offset) * Math.cos(Math.PI/2);
        const headY = adjustedCenterY + (radius + offset) * Math.sin(Math.PI/2);
        
        const tangentAngle = Math.PI/2 - Math.PI/2;
        
        ctx.beginPath();
        ctx.moveTo(headX, headY);
        ctx.lineTo(headX - arrowSize * 0.6 * Math.cos(tangentAngle - Math.PI/6), 
                   headY - arrowSize * 0.6 * Math.sin(tangentAngle - Math.PI/6));
        ctx.lineTo(headX - arrowSize * 0.6 * Math.cos(tangentAngle + Math.PI/6), 
                   headY - arrowSize * 0.6 * Math.sin(tangentAngle + Math.PI/6));
        ctx.closePath();
        ctx.fill();
    }
    
    ctx.restore();
}
        function startDrawing(e) {
    // 아이패드 호환성을 위한 강력한 차단
    if (!isPracticeMode || isShowingStrokes || strokeAnimationInterval !== null) {
        if (e && e.preventDefault) e.preventDefault();
        if (e && e.stopPropagation) e.stopPropagation();
        return false;
    }
    
    // 사용자가 그리기 시작하면 획순 애니메이션 완전 중단
    stopStrokeAnimation();
    
    if (e && e.preventDefault) e.preventDefault();
    if (e && e.stopPropagation) e.stopPropagation();
    
    isDrawing = true;
    hasUserDrawn = true;
    const rect = canvas.getBoundingClientRect();
    
    let x, y;
    if (e.type === 'touchstart' && e.touches && e.touches.length > 0) {
        const touch = e.touches[0];
        x = touch.clientX - rect.left;
        y = touch.clientY - rect.top;
    } else if (e.clientX !== undefined && e.clientY !== undefined) {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
    } else {
        return false;
    }
    
    // 아이패드 호환성을 위한 완전한 스타일 설정
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = '#000000';
    ctx.fillStyle = 'transparent';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.setLineDash([]);
    
    ctx.beginPath();
    ctx.moveTo(x, y);
    
    return false;
}
        
     function draw(e) {
    // 아이패드 호환성을 위한 강력한 차단
    if (!isDrawing || !isPracticeMode || isShowingStrokes || strokeAnimationInterval !== null) {
        if (e && e.preventDefault) e.preventDefault();
        if (e && e.stopPropagation) e.stopPropagation();
        return false;
    }
    
    if (e && e.preventDefault) e.preventDefault();
    if (e && e.stopPropagation) e.stopPropagation();
    
    const rect = canvas.getBoundingClientRect();
    
    let x, y;
    if (e.type === 'touchmove' && e.touches && e.touches.length > 0) {
        const touch = e.touches[0];
        x = touch.clientX - rect.left;
        y = touch.clientY - rect.top;
    } else if (e.clientX !== undefined && e.clientY !== undefined) {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
    } else {
        return false;
    }
    
    // 아이패드에서 스타일이 변경되지 않도록 강제 설정
    if (ctx.strokeStyle !== '#000000') {
        ctx.strokeStyle = '#000000';
    }
    if (ctx.lineWidth !== 8) {
        ctx.lineWidth = 8;
    }
    
    ctx.lineTo(x, y);
    ctx.stroke();
    
    return false;
}
        
           function stopDrawing(e) {
    if (e && e.preventDefault) e.preventDefault();
    if (e && e.stopPropagation) e.stopPropagation();
    
    isDrawing = false;
    
    // 아이패드에서 그리기 완료 후 스타일 정리
    if (ctx) {
        ctx.restore();
    }
    
    return false;
}
        
                // 디버깅을 위한 간단한 테스트 함수
                function testModalSound() {
                    console.log('테스트 소리 재생');
                    playModalSound('테스트');
                }
        
                function replayModalSound() {
                    playJamoSound(currentSound);
                }
        
          function playJamoSound(sound, cardElement) {
    // 모든 카드의 playing 클래스 제거
    document.querySelectorAll('.jamo-card.playing').forEach(card => {
        card.classList.remove('playing');
    });

    // 통합 음성 재생 함수 사용
    playUnifiedSound(sound, cardElement);
}
// ====== 생년월일 드롭다운 관련 함수들 (전역 함수로 정의) ======
function initializeBirthdateDropdowns() {
    console.log('생년월일 드롭다운 초기화 시작'); // 디버깅용
    
    // 아이디/비밀번호 찾기용 드롭다운
    initializeDropdown('findYear', 'findMonth', 'findDay');
    
    // 회원가입용 드롭다운
    initializeDropdown('signupYear', 'signupMonth', 'signupDay');
    
    console.log('생년월일 드롭다운 초기화 완료'); // 디버깅용
}

function initializeDropdown(yearId, monthId, dayId) {
    const yearSelect = document.getElementById(yearId);
    const monthSelect = document.getElementById(monthId);
    const daySelect = document.getElementById(dayId);
    
    console.log(`드롭다운 초기화 시도: ${yearId}, ${monthId}, ${dayId}`); // 디버깅용
    
    if (!yearSelect || !monthSelect || !daySelect) {
        console.log(`드롭다운 요소를 찾을 수 없음: ${yearId}, ${monthId}, ${dayId}`); // 디버깅용
        return;
    }
    
    console.log(`드롭다운 요소 찾음: ${yearId}, ${monthId}, ${dayId}`); // 디버깅용
    
    // 기존 옵션들 제거 (중복 방지)
    yearSelect.innerHTML = '<option value="">연도</option>';
    monthSelect.innerHTML = '<option value="">월</option>';
    daySelect.innerHTML = '<option value="">일</option>';
    
    // 연도 옵션 추가 (1950년부터 현재년도까지)
    const currentYear = new Date().getFullYear();
    for (let year = currentYear; year >= 1950; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearSelect.appendChild(option);
    }
    console.log(`연도 옵션 추가 완료: ${currentYear}년부터 1950년까지`); // 디버깅용
    
    // 월 옵션 추가 (1월부터 12월까지)
    for (let month = 1; month <= 12; month++) {
        const option = document.createElement('option');
        option.value = month.toString().padStart(2, '0');
        option.textContent = month + '월';
        monthSelect.appendChild(option);
    }
    console.log('월 옵션 추가 완료: 1월부터 12월까지'); // 디버깅용
    
    // 일 옵션 추가 함수
    function updateDayOptions() {
        daySelect.innerHTML = '<option value="">일</option>';
        
        const year = parseInt(yearSelect.value);
        const month = parseInt(monthSelect.value);
        
        if (year && month) {
            const lastDay = new Date(year, month, 0).getDate();
            
            for (let day = 1; day <= lastDay; day++) {
                const option = document.createElement('option');
                option.value = day.toString().padStart(2, '0');
                option.textContent = day + '일';
                daySelect.appendChild(option);
            }
            console.log(`일 옵션 업데이트: ${year}년 ${month}월 - ${lastDay}일까지`); // 디버깅용
        } else {
            // 연도나 월이 선택되지 않은 경우 기본적으로 31일까지 표시
            for (let day = 1; day <= 31; day++) {
                const option = document.createElement('option');
                option.value = day.toString().padStart(2, '0');
                option.textContent = day + '일';
                daySelect.appendChild(option);
            }
            console.log('일 옵션 기본값 설정: 1일부터 31일까지'); // 디버깅용
        }
    }
    
    // 기존 이벤트 리스너 제거 (중복 방지)
    yearSelect.removeEventListener('change', updateDayOptions);
    monthSelect.removeEventListener('change', updateDayOptions);
    
    // 연도나 월이 변경되면 일 옵션 업데이트
    yearSelect.addEventListener('change', updateDayOptions);
    monthSelect.addEventListener('change', updateDayOptions);
    
    // 초기 일 옵션 설정
    updateDayOptions();
    
    console.log(`${yearId} 드롭다운 초기화 완료`); // 디버깅용
}

// 아이디/비밀번호 찾기 관련 함수
let currentFindMode = 'id';

function showFindForm() {
    console.log('찾기 폼 표시 시작'); // 디버깅용
    
    document.getElementById('authForm').classList.add('hidden');
    document.getElementById('findForm').classList.remove('hidden');
    
    // 로그인/회원가입 탭 숨기기
    document.querySelector('.auth-tabs').style.display = 'none';
    
    // 찾기 폼이 렌더링된 후 드롭다운 초기화
    setTimeout(() => {
        console.log('찾기 폼 렌더링 후 드롭다운 초기화'); // 디버깅용
        initializeBirthdateDropdowns();
    }, 100);
    
    console.log('찾기 폼 표시 완료'); // 디버깅용
}

function switchFindTab(mode) {
    currentFindMode = mode;
    
    // 모든 탭 비활성화
    document.querySelectorAll('.find-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 선택된 탭 활성화
    document.querySelector(`[onclick="switchFindTab('${mode}')"]`).classList.add('active');
    
    // 버튼 텍스트 변경
    const submitBtn = document.getElementById('findSubmitBtn');
    submitBtn.textContent = mode === 'id' ? '아이디 찾기' : '비밀번호 찾기';
}

function hideFindForm() {
    document.getElementById('authForm').classList.remove('hidden');
    document.getElementById('findForm').classList.add('hidden');
    document.getElementById('findFormContent').reset();
    
    // 로그인/회원가입 탭 다시 보이기
    document.querySelector('.auth-tabs').style.display = 'flex';
}

// 로그인 관련 이벤트 처리
document.addEventListener('DOMContentLoaded', function() {
    console.log('페이지 로드 완료'); // 디버깅용
    
    // 페이지 로드 시 드롭다운 초기화
    initializeBirthdateDropdowns();
    
    document.getElementById('authForm').addEventListener('submit', function(e) {
        e.preventDefault();
        console.log('폼 제출됨, 현재 모드:', currentAuthMode); // 디버깅용
        
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        const nickname = document.getElementById('nickname').value;

        console.log('입력값 확인:', { username, password, nickname }); // 디버깅용

     if (currentAuthMode === 'login') {
            console.log('로그인 시도'); // 디버깅용
            // 로그인 처리
            login(username, password).then(result => {
                console.log('로그인 결과:', result); // 디버깅용
                if (result.success) {
                    alert('로그인 성공!');
                } else {
                    alert(result.message);
                }
            }).catch(error => {
                console.error('로그인 오류:', error);
                alert('로그인 중 오류가 발생했습니다.');
            });
        } else if (currentAuthMode === 'signup') {
            console.log('회원가입 시도'); // 디버깅용
            // 회원가입 처리
            if (!nickname) {
                alert('이름을 입력해주세요.');
                return;
            }
            
            const year = document.getElementById('signupYear').value;
            const month = document.getElementById('signupMonth').value;
            const day = document.getElementById('signupDay').value;

            console.log('생년월일 입력값:', { year, month, day }); // 디버깅용

            // 생년월일 조합 및 유효성 검사
            if (!year || !month || !day) {
                alert('생년월일을 모두 선택해주세요.');
                return;
            }

            const birthdate = `${year}-${month}-${day}`;
            console.log('회원가입 시도:', { username, nickname, birthdate }); // 디버깅용
            
            signup(username, password, nickname, birthdate).then(success => {
                console.log('회원가입 결과:', success); // 디버깅용
                if (success) {
                    alert('회원가입 성공!');
                } else {
                    alert('이미 존재하는 아이디입니다.');
                }
            }).catch(error => {
                console.error('회원가입 오류:', error);
                alert('회원가입 중 오류가 발생했습니다.');
            });
        } else {
            console.error('알 수 없는 모드:', currentAuthMode); // 디버깅용
            alert('알 수 없는 오류가 발생했습니다.');
        }
    });

   // 아이디/비밀번호 찾기 폼 이벤트 리스너
document.getElementById('findFormContent').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const name = document.getElementById('findName').value;
    const year = document.getElementById('findYear').value;
    const month = document.getElementById('findMonth').value;
    const day = document.getElementById('findDay').value;

    if (!year || !month || !day) {
        alert('생년월일을 모두 선택해주세요.');
        return;
    }

    const birthdate = `${year}-${month}-${day}`;
    console.log('검색 시도:', { name, birthdate });
    
    try {
        // 버튼 상태 변경
        const submitBtn = document.getElementById('findSubmitBtn');
        const originalText = submitBtn.textContent;
        submitBtn.textContent = '검색 중...';
        submitBtn.disabled = true;
        
        const snapshot = await db.collection('users').get();
        let found = false;
        let foundData = null;
        
        // 모든 문서를 배열로 변환하여 처리
        const docs = [];
        snapshot.forEach(doc => {
            docs.push({
                id: doc.id,
                data: doc.data()
            });
        });
        
        console.log('총 사용자 수:', docs.length);
        
        // 각 사용자 데이터 확인
        for (const doc of docs) {
            const userData = doc.data;
            console.log('확인 중:', doc.id, userData.nickname, userData.birthdate);
            
            if (userData.nickname === name && userData.birthdate === birthdate) {
                found = true;
                foundData = {
                    id: doc.id,
                    password: userData.password
                };
                break;
            }
        }
        
        // 버튼 상태 복구
        submitBtn.textContent = originalText;
        submitBtn.disabled = false;
        
        if (found) {
            alert(`찾은 아이디: ${foundData.id}\n찾은 비밀번호: ${foundData.password}`);
        } else {
            alert('일치하는 정보를 찾을 수 없습니다.');
        }
        
        hideFindForm();
        
    } catch (error) {
        console.error('검색 오류:', error);
        
        // 버튼 상태 복구
        const submitBtn = document.getElementById('findSubmitBtn');
        submitBtn.textContent = '찾기';
        submitBtn.disabled = false;
        
        alert('검색 중 오류가 발생했습니다. 다시 시도해주세요.');
    }
});


    // 페이지 로드시 로그인 상태 확인
const savedUser = localStorage.getItem('currentUser');
if (savedUser) {
    try {
        const userInfo = JSON.parse(savedUser);
        console.log('저장된 사용자 정보 복구 시도:', userInfo.username);
        
        getUserData(userInfo.username).then(userData => {
            if (userData) {
                currentUser = {
                    username: userInfo.username,
                    nickname: userData.nickname,
                    stats: userData.stats || {
                        consonantCorrect: {},
                        vowelCorrect: {},
                        finalCorrect: {},
                        consonantTotal: {},
                        vowelTotal: {},
                        finalTotal: {}
                    }
                };
                updateLoginUI();
                console.log('사용자 상태 복구 완료:', currentUser.nickname);
            } else {
                console.log('저장된 사용자 정보가 유효하지 않음');
                localStorage.removeItem('currentUser');
            }
        }).catch(error => {
            console.error('사용자 상태 복구 오류:', error);
            localStorage.removeItem('currentUser');
        });
    } catch (error) {
        console.error('저장된 사용자 정보 파싱 오류:', error);
        localStorage.removeItem('currentUser');
    }
}
});

// 퍼센트 계산 함수 (단계별 차등 적용)
function calculatePercentage(jamo, type) {
    if (!currentUser || !currentUser.stats) return 0;
    
    let totalKey;
    
    if (type === 'consonant') {
        totalKey = 'consonantTotal';
    } else if (type === 'vowel') {
        totalKey = 'vowelTotal';
    } else if (type === 'final') {
        totalKey = 'finalTotal';
    } else {
        return 0;
    }
    
    const totalData = currentUser.stats[totalKey] || {};
    const totalCount = totalData[jamo] || 0;
    
    // 단계별 차등 퍼센트 계산
    let percentage = 0;
    
    if (totalCount <= 20) {
        // 처음 20회: 1회당 3% (0~60%)
        percentage = totalCount * 3;
    } else if (totalCount <= 50) {
        // 21-50회: 1회당 2% (60~120% → 60~90%)
        percentage = 60 + (totalCount - 20) * 2;
    } else if (totalCount <= 100) {
        // 51-100회: 1회당 1% (90~140% → 90~100%)
        percentage = 90 + (totalCount - 50) * 0.2;
    } else {
        // 100회 이상: 100% 유지
        percentage = 100;
    }
    
    // 최대 100%로 제한
    return Math.min(Math.round(percentage), 100);
}
// 게임 통계 업데이트 함수 (20문제 맞출 때마다 1회)
function updateGameStats(word, isCorrect) {
    if (!currentUser || !currentUser.stats) return;
    
    // 게임 카운터 초기화
    if (!currentUser.stats.gameCounters) {
        currentUser.stats.gameCounters = {};
    }
    
    // 단어를 자모로 분해
    for (let char of word) {
        const decomposed = decomposeHangul(char);
        
        if (decomposed) {
            // 초성 처리
            if (decomposed.initial) {
                updateGameStatForJamo(decomposed.initial, 'consonant', isCorrect);
            }
            
            // 중성 처리
            const vowel = decomposed.medial || decomposed.vowel;
            if (vowel) {
                updateGameStatForJamo(vowel, 'vowel', isCorrect);
            }
            
            // 종성 처리
            if (decomposed.final) {
                updateGameStatForJamo(decomposed.final, 'final', isCorrect);
            }
        }
    }
    
    // Firebase에 저장
    updateUserStats(currentUser.username, currentUser.stats);
}

// 게임용 개별 자모 통계 업데이트 함수 (새로 추가)
function updateGameStatForJamo(jamo, type, isCorrect) {
    let correctKey, totalKey, counterKey;
    
    if (type === 'consonant') {
        correctKey = 'consonantCorrect';
        totalKey = 'consonantTotal';
        counterKey = 'consonantGameCounter';
    } else if (type === 'vowel') {
        correctKey = 'vowelCorrect';
        totalKey = 'vowelTotal';
        counterKey = 'vowelGameCounter';
    } else if (type === 'final') {
        correctKey = 'finalCorrect';
        totalKey = 'finalTotal';
        counterKey = 'finalGameCounter';
    } else {
        return;
    }
    
    // 통계 객체 초기화
    if (!currentUser.stats[totalKey]) currentUser.stats[totalKey] = {};
    if (!currentUser.stats[correctKey]) currentUser.stats[correctKey] = {};
    if (!currentUser.stats.gameCounters[counterKey]) currentUser.stats.gameCounters[counterKey] = {};
    
    if (!currentUser.stats[totalKey][jamo]) currentUser.stats[totalKey][jamo] = 0;
    if (!currentUser.stats[correctKey][jamo]) currentUser.stats[correctKey][jamo] = 0;
    if (!currentUser.stats.gameCounters[counterKey][jamo]) currentUser.stats.gameCounters[counterKey][jamo] = 0;
    
    // 정답일 때만 카운터 증가
    if (isCorrect) {
        currentUser.stats.gameCounters[counterKey][jamo]++;
        
        // 20문제 맞출 때마다 1회 학습으로 기록
        if (currentUser.stats.gameCounters[counterKey][jamo] >= 20) {
            currentUser.stats[totalKey][jamo]++;
            currentUser.stats[correctKey][jamo]++;
            
            // 카운터 리셋
            currentUser.stats.gameCounters[counterKey][jamo] = 0;
        }
    }
}

// 학습 활동 통계 업데이트 함수 (간소화)
function updateLearningStats(jamo, type) {
    if (!currentUser || !currentUser.stats) return;
    
    let correctKey, totalKey;
    
    if (type === 'consonant') {
        correctKey = 'consonantCorrect';
        totalKey = 'consonantTotal';
    } else if (type === 'vowel') {
        correctKey = 'vowelCorrect';
        totalKey = 'vowelTotal';
    } else if (type === 'final') {
        correctKey = 'finalCorrect';
        totalKey = 'finalTotal';
    } else {
        return;
    }
    
    // 통계 객체 초기화
    if (!currentUser.stats[totalKey]) currentUser.stats[totalKey] = {};
    if (!currentUser.stats[correctKey]) currentUser.stats[correctKey] = {};
    if (!currentUser.stats[totalKey][jamo]) currentUser.stats[totalKey][jamo] = 0;
    if (!currentUser.stats[correctKey][jamo]) currentUser.stats[correctKey][jamo] = 0;
    
   // 실제 그리기 활동 완료 시에만 1회 학습으로 기록
currentUser.stats[totalKey][jamo]++;
currentUser.stats[correctKey][jamo]++; // 학습 완료는 항상 성공으로 간주
           
// Firebase에 저장
updateUserStats(currentUser.username, currentUser.stats);
}  // ← updateLearningStats 함수를 여기서 닫기

// 가장 간단한 모바일 호환 버전
function togglePassword() {
    const password = document.getElementById('password');
    
    if (!password) return;
    
    // 현재 타입 확인 후 변경
    if (password.type === 'password') {
        password.type = 'text';
    } else {
        password.type = 'password';
    }
    
    // 토글 버튼 색상 변경 (있는 경우에만)
    const eye = document.querySelector('span[onclick="togglePassword()"]');
    if (eye) {
        eye.style.color = password.type === 'text' ? '#4CAF50' : '#999';
    }
}

// 탈퇴 모달 표시
function showWithdrawModal() {
    document.getElementById('withdrawModal').style.display = 'flex';
}

// 탈퇴 모달 닫기
function closeWithdrawModal() {
    document.getElementById('withdrawModal').style.display = 'none';
}

// 탈퇴 확인 및 처리
async function confirmWithdraw() {
    if (!currentUser) {
        alert('로그인이 필요합니다.');
        return;
    }
    
    try {
        // Firebase에서 사용자 데이터 삭제
        await db.collection('users').doc(currentUser.username).delete();
        
        // 현재 사용자 정보 초기화
        currentUser = null;
       localStorage.removeItem('currentUser');
        
        // UI 업데이트
        updateLoginUI();
        
        // 모달 닫기
        closeWithdrawModal();
        
        // 메인 메뉴로 이동
        showMainMenu();
        
        alert('회원 탈퇴가 완료되었습니다. 그동안 이용해 주셔서 감사합니다.');
        
    } catch (error) {
        console.error('탈퇴 처리 중 오류:', error);
        alert('탈퇴 처리 중 오류가 발생했습니다. 다시 시도해 주세요.');
    }
}

    </script>
